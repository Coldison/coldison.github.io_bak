<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>python的使用索引</title>
    <link href="/2022/07/27/python%E7%9A%84%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95/"/>
    <url>/2022/07/27/python%E7%9A%84%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95/</url>
    
    <content type="html"><![CDATA[<p>Python的高级用法尤其是multiprocessing看了很久还是不会用，所以同样开个索引贴记录下。</p><ul><li><a href="https://blog.csdn.net/NasonYehfm/article/details/90167811">Python ABC(抽象基类)</a></li><li><a href="python%E7%9A%84@abstractmethod">python的@abstractmethod</a></li><li><a href="http://c.biancheng.net/view/4561.html">@property装饰器</a></li><li><a href="https://pypi.org/project/cloudpickle/">cloudpickle</a></li><li><a href="https://docs.python.org/zh-cn/3/library/multiprocessing.html#contexts-and-start-methods">multiprocessing库文档</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>教程</category>
      
      <category>python使用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>torch的使用索引</title>
    <link href="/2022/07/26/torch%E7%9A%84%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95/"/>
    <url>/2022/07/26/torch%E7%9A%84%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95/</url>
    
    <content type="html"><![CDATA[<p>新开一篇文章，记录一些博客文章索引或者笔记。暂时还没有细致地读文档的需求，所以看看博客解决问题。</p><ul><li><a href="https://blog.csdn.net/hfut_lf/article/details/122156232">torch 单机多卡运行</a></li><li><code>torch.set_num_threads</code>设置多线程时占用的线程数，300%即为使用三个核心。</li></ul>]]></content>
    
    
    <categories>
      
      <category>教程</category>
      
      <category>pytorch使用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RL</tag>
      
      <tag>ML</tag>
      
      <tag>pytorch</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MAPPO的实现细节(一)</title>
    <link href="/2022/07/20/MAPPO%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82/"/>
    <url>/2022/07/20/MAPPO%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82/</url>
    
    <content type="html"><![CDATA[<p>之前研读过light-mappo的代码，对于其中强化学习的部分已经有所了解，想要自己跑一下但是环境的部分被抽走了，所以还是看看原版的代码并做点笔记。</p><p>先介绍一下MAPPO，原文<a href="https://arxiv.org/abs/2103.01955">The Surprising Effectiveness of PPO in Cooperative, Multi-Agent Games</a>，主要解决的问题是，将PPO算法应用在Multi-Agent环境中需要使用的一些技巧，从IPPO扩展到MAPPO。项目地址：<a href="https://github.com/marlbenchmark/on-policy">MAPPO</a>。</p><h3 id="MAPPO的环境配置"><a href="#MAPPO的环境配置" class="headerlink" title="MAPPO的环境配置"></a>MAPPO的环境配置</h3><p>这个项目的第一个难点就是环境配置。项目提供了requirements.txt，使用 <code>pip install -r requirements.txt</code>安装对应的环境。也提供了environment.yaml,  使用 <code>conda env create -f environment.yaml</code> 命令安装对于的环境。但是由于本项目使用的python 3.6不再维护，很多包的版本也已经过期，所以使用上述命令并不能使得项目能够运行。使用 <code>conda create -n py37 python=3.7</code>命令创建环境。然后建议使用 <code>pip install -r requirements.txt</code>。使用 <code>pip freeze &gt; requirements.txt</code>命令生成。我使用的是<a href="https://link.jscdn.cn/1drv/aHR0cHM6Ly8xZHJ2Lm1zL3QvcyFBa3A3T0FGTWxmRUtodkpTY3BsYjJfMVFkZzZkYnc_ZT1FZDduckM.txt">requirements.txt</a>, 由于使用的CUDA环境不一样，pytorch请自行安装</p><p>项目使用了wandb作为训练logger，关于wandb的使用参见，<a href="https://zhuanlan.zhihu.com/p/493093033">wandb使用教程(一)：基础用法</a>。</p><p>在scripts文件夹中给出了很多运行的脚本，但是sh脚本对我来说始终有编码的问题，而python本身就是脚本语言，所以我直接在py文件中添加参数，当然也可以使用命令行运行，我觉得要比sh脚本方便很多。</p><p>我选择了足球作为应用的环境，本项目使用了谷歌足球的环境，参见<a href="https://github.com/google-research/football/blob/master/README.md">gfootball</a>, 按照说明按照对应的依赖与环境。将train_football.py放到根目录，然后按照sh文件修改对应的参数，使用wandb需要将对应的用户名改成自己的用户名。</p><p>至此应该是能够顺利运行本项目了。下图是我的训练结果，好像不太行。<img src="https://link.jscdn.cn/1drv/aHR0cHM6Ly8xZHJ2Lm1zL3UvcyFBa3A3T0FGTWxmRUtodlFxYlZwaWJSNHg3U0htaVE_ZT1ISFNYQTY.png" alt="足球环境训练结果"></p><h3 id="多线程Env"><a href="#多线程Env" class="headerlink" title="多线程Env"></a>多线程Env</h3><p>能够运行之后，在train_football.py中的第一步是创建Env。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">make_train_env</span>(<span class="hljs-params">all_args</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_env_fn</span>(<span class="hljs-params">rank</span>):</span><br>        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">init_env</span>():</span><br>            <span class="hljs-keyword">if</span> all_args.env_name == <span class="hljs-string">&quot;Football&quot;</span>:<br>                env = FootballEnv(all_args)<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Can not support the &quot;</span> +<br>                      all_args.env_name + <span class="hljs-string">&quot; environment.&quot;</span>)<br>                <span class="hljs-keyword">raise</span> NotImplementedError<br>            env.seed(all_args.seed + rank * <span class="hljs-number">1000</span>)<br>            <span class="hljs-keyword">return</span> env<br>        <span class="hljs-keyword">return</span> init_env<br>    <span class="hljs-keyword">if</span> all_args.n_rollout_threads == <span class="hljs-number">1</span>:<br>        <span class="hljs-keyword">return</span> DummyVecEnv([get_env_fn(<span class="hljs-number">0</span>)])<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> SubprocVecEnv([get_env_fn(i) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<br>            all_args.n_rollout_threads)])<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">make_eval_env</span>(<span class="hljs-params">all_args</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_env_fn</span>(<span class="hljs-params">rank</span>):</span><br>        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">init_env</span>():</span><br>            <span class="hljs-keyword">if</span> all_args.env_name == <span class="hljs-string">&quot;Football&quot;</span>:<br>                env = FootballEnv(all_args)<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Can not support the &quot;</span> +<br>                      all_args.env_name + <span class="hljs-string">&quot; environment.&quot;</span>)<br>                <span class="hljs-keyword">raise</span> NotImplementedError<br>            env.seed(all_args.seed * <span class="hljs-number">50000</span> + rank * <span class="hljs-number">10000</span>)<br>            <span class="hljs-keyword">return</span> env<br>        <span class="hljs-keyword">return</span> init_env<br>    <span class="hljs-keyword">if</span> all_args.n_eval_rollout_threads == <span class="hljs-number">1</span>:<br>        <span class="hljs-keyword">return</span> DummyVecEnv([get_env_fn(<span class="hljs-number">0</span>)])<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> SubprocVecEnv([get_env_fn(i) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<br>            all_args.n_eval_rollout_threads)])<br><br><span class="hljs-comment"># env init</span><br>envs = make_train_env(all_args)<br>eval_envs = make_eval_env(all_args) <span class="hljs-keyword">if</span> all_args.use_eval <span class="hljs-keyword">else</span> <span class="hljs-literal">None</span><br>num_agents = all_args.num_agents<br></code></pre></td></tr></table></figure><p>为了实现多线程执行，并且统一收取不同运行环境中的数据，使用SubprocVecEnv创建多线程运行环境。 这里传入SubprocvecEnv的参数env_fns是一个函数，这个函数的返回值是一个环境，这个环境的初始化函数是init_env。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SubprocVecEnv</span>(<span class="hljs-params">ShareVecEnv</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, env_fns, spaces=<span class="hljs-literal">None</span></span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        envs: list of gym environments to run in subprocesses</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        self.waiting = <span class="hljs-literal">False</span><br>        self.closed = <span class="hljs-literal">False</span><br>        nenvs = <span class="hljs-built_in">len</span>(env_fns)<br>        self.remotes, self.work_remotes = <span class="hljs-built_in">zip</span>(*[Pipe() <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(nenvs)])<br>        self.ps = [Process(target=worker, args=(work_remote, remote, CloudpickleWrapper(env_fn)))<br>                   <span class="hljs-keyword">for</span> (work_remote, remote, env_fn) <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(self.work_remotes, self.remotes, env_fns)]<br>        <span class="hljs-keyword">for</span> p <span class="hljs-keyword">in</span> self.ps:<br>            p.daemon = <span class="hljs-literal">True</span>  <span class="hljs-comment"># if the main process crashes, we should not cause things to hang </span><br>            p.start()<br>        <span class="hljs-keyword">for</span> remote <span class="hljs-keyword">in</span> self.work_remotes:<br>            remote.close()<br><br>        self.remotes[<span class="hljs-number">0</span>].send((<span class="hljs-string">&#x27;get_spaces&#x27;</span>, <span class="hljs-literal">None</span>))<br>        observation_space, share_observation_space, action_space = self.remotes[<span class="hljs-number">0</span>].recv()<br>        ShareVecEnv.__init__(self, <span class="hljs-built_in">len</span>(env_fns), observation_space,<br>                             share_observation_space, action_space)<br></code></pre></td></tr></table></figure><p>首先是创建每个进程的通信管道，<code>multiprocessing.Pipe()</code>提供了一个管道，可以用来进行进程间的通信。然后将通信进程绑定到worker当中，创建不同的进程。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">worker</span>(<span class="hljs-params">remote, parent_remote, env_fn_wrapper</span>):</span><br>    <span class="hljs-comment"># 指示当前进程将不会再往队列中放入对象。双工的通信管道当成单工使用</span><br>    parent_remote.close()<br>    env = env_fn_wrapper.x()<br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        cmd, data = remote.recv()<br>        <span class="hljs-keyword">if</span> cmd == <span class="hljs-string">&#x27;step&#x27;</span>:<br>            ob, reward, done, info = env.step(data)<br>            <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;bool&#x27;</span> <span class="hljs-keyword">in</span> done.__class__.__name__:<br>                <span class="hljs-keyword">if</span> done:<br>                    ob = env.reset()<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">if</span> np.<span class="hljs-built_in">all</span>(done):<br>                    ob = env.reset()<br><br>            remote.send((ob, reward, done, info))<br>        <span class="hljs-keyword">elif</span> cmd == <span class="hljs-string">&#x27;reset&#x27;</span>:<br>            ob = env.reset()<br>            remote.send((ob))<br>        <span class="hljs-keyword">elif</span> cmd == <span class="hljs-string">&#x27;render&#x27;</span>:<br>            <span class="hljs-keyword">if</span> data == <span class="hljs-string">&quot;rgb_array&quot;</span>:<br>                fr = env.render(mode=data)<br>                remote.send(fr)<br>            <span class="hljs-keyword">elif</span> data == <span class="hljs-string">&quot;human&quot;</span>:<br>                env.render(mode=data)<br>        <span class="hljs-keyword">elif</span> cmd == <span class="hljs-string">&#x27;reset_task&#x27;</span>:<br>            ob = env.reset_task()<br>            remote.send(ob)<br>        <span class="hljs-keyword">elif</span> cmd == <span class="hljs-string">&#x27;close&#x27;</span>:<br>            env.close()<br>            remote.close()<br>            <span class="hljs-keyword">break</span><br>        <span class="hljs-keyword">elif</span> cmd == <span class="hljs-string">&#x27;get_spaces&#x27;</span>:<br>            remote.send((env.observation_space, env.share_observation_space, env.action_space))<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">raise</span> NotImplementedError<br></code></pre></td></tr></table></figure><p>然后在每个worker进程中，使用env_fn_wrapper.x()来创建环境，然后使用remote.recv()来接收命令，然后使用<code>remote.send()</code>来发送数据。在worker中的worker_remote相应地发送进程数据。其中这里足球环境返回的数据是ob, reward, done, info。</p><p>通过这种方式，实现了多进程环境的创建、初始化与通信。然后使用<code>step()</code>方法收取不同进程产生的训练数据。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SubprocVecEnv</span>(<span class="hljs-params">ShareVecEnv</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">step_async</span>(<span class="hljs-params">self, actions</span>):</span><br>        <span class="hljs-keyword">for</span> remote, action <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(self.remotes, actions):<br>            remote.send((<span class="hljs-string">&#x27;step&#x27;</span>, action))<br>        self.waiting = <span class="hljs-literal">True</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">step_wait</span>(<span class="hljs-params">self</span>):</span><br>        results = [remote.recv() <span class="hljs-keyword">for</span> remote <span class="hljs-keyword">in</span> self.remotes]<br>        self.waiting = <span class="hljs-literal">False</span><br>        obs, rews, dones, infos = <span class="hljs-built_in">zip</span>(*results)<br>        <span class="hljs-keyword">return</span> np.stack(obs), np.stack(rews), np.stack(dones), infos<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">step</span>(<span class="hljs-params">self, actions</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        Step the environments synchronously.</span><br><span class="hljs-string"></span><br><span class="hljs-string">        This is available for backwards compatibility.</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        self.step_async(actions)<br>        <span class="hljs-keyword">return</span> self.step_wait()<br></code></pre></td></tr></table></figure><p>关于多线程Env的总结，从流程上，对google football这个环境进行了三层封装，一层是将football封装成FootballEnv，在这之中可以配置reward，以及render方法，第二层是把这个环境塞进worker并且配置通信进程，第三层是将多线程worker封装成一个新的SubprocVecEnv，并且统一进行step, reset, close等操作。</p><pre><code class=" mermaid">classDiagramclass SubprocVecEnvSubprocVecEnv: psSubprocVecEnv: step()class psps: workerps: remoteps: remote.recv()ps: remote.send()SubprocVecEnv &lt;-- psclass workerworker: FootballEnvps &lt;-- worker</code></pre>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>强化学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RL</tag>
      
      <tag>MARL</tag>
      
      <tag>MAPPO</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>复制博客园或者CSDN文章</title>
    <link href="/2022/07/19/%E5%A4%8D%E5%88%B6%E5%8D%9A%E5%AE%A2%E5%9B%AD%E6%88%96%E8%80%85CSDN%E6%96%87%E7%AB%A0/"/>
    <url>/2022/07/19/%E5%A4%8D%E5%88%B6%E5%8D%9A%E5%AE%A2%E5%9B%AD%E6%88%96%E8%80%85CSDN%E6%96%87%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<p>在转载博客的时候，出于对于站点的不信任，还是倾向于将对应的博文保存到本地。</p><p>参考了如下方法，可以直接提取CSDN或者博客园中的博文内容，并将html直接粘贴到markdown中，实现复制博文的效果，其他站点应该也类似，不过显然图床的问题也并没有解决，会随时挂掉。</p><p>以下内容为直接粘贴html元素：</p><hr><div id="article_content" class="article_content clearfix">        <link rel="stylesheet" href="https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/ck_htmledit_views-bbac9290cd.css">                <div id="content_views" class="markdown_views prism-atom-one-dark">                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>                    </svg>                    <p><strong>复制csdn或者博客园文章时，图片无法直接粘贴过来解决办法。</strong></p> <p>1、csdn 文章页面，打开浏览器开发者工具</p> <p>2、找到文章正文对应的 html 元素，按ctrl+f输入标签头关键字 （含 "article_content"标签头(csdn文章) ，如果是博客园文章，则标签头是“cnblogs_post_body”）</p> <p><img src="https://img-blog.csdnimg.cn/img_convert/264838c821805a1acf1fdd5cc54e7268.png" alt="img"></p> <p>3、在该元素源代码上右键 “Copy”->“Copy element”</p> <p><img src="https://img-blog.csdnimg.cn/img_convert/bd91c1b2f1b0994e12545d15ad1d7dc9.png" alt="img"></p> <p>4、新建一个 txt 文件，将后缀改为 .html ，把刚复制的 源代码 粘贴到文件中，浏览器打开，此时复制全文，到博客园 添加新随笔，粘贴。<br> 5、或者复制全文到markdown，到cadn 添加新随笔导入markdown。</p> <blockquote>  <p>解决方法参考：https://jingyan.baidu.com/article/0964eca24e159c8285f53618.html</p> </blockquote>                </div><div><div></div></div>                <link href="https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-3fd7f7a902.css" rel="stylesheet">                <link href="https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-49037e4d27.css" rel="stylesheet">        </div>]]></content>
    
    
    <categories>
      
      <category>教程</category>
      
      <category>博客设置</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网页</tag>
      
      <tag>博客</tag>
      
      <tag>blog</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ffmpeg使用(未完)</title>
    <link href="/2022/07/18/ffmpeg%E4%BD%BF%E7%94%A8/"/>
    <url>/2022/07/18/ffmpeg%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>一直想建立一个视频搬运的工作流，比如在b站上看到什么视频了，复制下链接，然后自动抓取转码和上传到推特或者油管，推特机器人账号需要自己有服务器，所以再议。<br>本文主要是收集一些ffmpeg的使用，视频剪辑软件对于我的需求来说太重了。比如我可能需要的是剪切，转码，音频提取（接翻译接口），字幕生成之类的，这些事情脚本做还是比较方便的。<br>然后因为还是参考别人的博客也没有自己读文档，先在这里记录一下地址。</p><h3 id="转码"><a href="#转码" class="headerlink" title="转码"></a>转码</h3><hr><div id="article_content" class="article_content clearfix">        <link rel="stylesheet" href="https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/ck_htmledit_views-bbac9290cd.css">                <div id="content_views" class="htmledit_views">                    <h1><a name="t0"></a>1. 准备</h1> <h3><a name="t1"></a>1.1 下载<a href="https://so.csdn.net/so/search?q=ffmpeg&spm=1001.2101.3001.7020" target="_blank" class="hl hl-1" data-report-click="{"spm":"1001.2101.3001.7020","dest":"https://so.csdn.net/so/search?q=ffmpeg&spm=1001.2101.3001.7020"}" data-tit="ffmpeg" data-pretit="ffmpeg">ffmpeg</a></h3> <p>进入ffmpeg官网<a href="https://www.ffmpeg.org/download.html" title="Download FFmpeg">Download FFmpeg</a>，根据自己的系统下载相应封装，这里以Windows为例。</p> <p style="text-align:center;"><img alt="" src="https://img-blog.csdnimg.cn/8cae5f53974c47e1a5dbe7f09e85c638.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IuP5pmTa8SBb-mUruebmA==,size_20,color_FFFFFF,t_70,g_se,x_16"></p> <p>选择篮框中任意一项进行下载。</p> <p style="text-align:center;">以下是选择第一项后的截图<img alt="" src="https://img-blog.csdnimg.cn/bc35a21c4c3d4d3c9c15ec70674ca02d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IuP5pmTa8SBb-mUruebmA==,size_20,color_FFFFFF,t_70,g_se,x_16"> </p> <p>下载合适的release，解压，将bin目录下的exe文件全部复制到目录<span style="color:#38d8f0;">C:\Windows\System32</span>下。</p> <h3><a name="t2"></a>1.2 cmd基础</h3> <p><strong>1.2.1 打开cmd</strong></p> <p>通过win+R，或 右键“开始”选择“运行”可进入cmd。</p> <p><strong>1.2.2 进入指定文件夹</strong></p> <p>①进入某个磁盘，直接盘符代号：如D：，然后回车，到D盘下（不用CD 命令切换）</p> <p>②输入dir，可以看到d盘下的各个文件名称</p> <p>③进入除根录以外的文件夹 ：  cd  文件夹路径（cd  xxx\xxx\xxx）回车</p> <p>④进入上一层目录 ： cd ../</p> <p>⑤返回D盘：cd\  </p> <p>⑥返回C盘：直接输入c: ，回车</p> <p>注： 不能在一打开cmd的时候运行cd  d:\xxx\xxx，需要先进入磁盘</p> <p>以进入<span style="color:#38d8f0;">E:\Videos\S</span>为例。</p> <p>在cmd中输入磁盘符<span style="color:#38d8f0;">E：</span><span style="color:#0d0016;">，回车。这一步不用cd命令。</span></p> <p><span style="color:#0d0016;">然后输入</span><span style="color:#38d8f0;">cd Videos\S</span><span style="color:#0d0016;">，回车即可。</span></p> <h1><a name="t3"></a>2. 文件转换</h1> <h3><a name="t4"></a>2.1 单个文件</h3> <pre data-index="0"><code class="hljs language-sql">ffmpeg <span class="hljs-operator">-</span>i "input.flv" <span class="hljs-operator">-</span>c <span class="hljs-keyword">copy</span> "output.mp4"</code><div class="hljs-button {2}" data-title="复制" onclick="hljs.copyCode(event)"></div></pre> <p>将这里的input改为你的文件名，output改为你想得到的文件名即可。</p> <h3><a name="t5"></a>2.2 批量转换</h3> <pre data-index="1"><code class="hljs language-perl"><span class="hljs-keyword">for</span> %i in (*.flv) <span class="hljs-keyword">do</span> ffmpeg -i <span class="hljs-string">"%i"</span> -c copy <span class="hljs-string">"%~ni.mp4"</span></code><div class="hljs-button {2}" data-title="复制" onclick="hljs.copyCode(event)"></div></pre> <p>这时新生成的mp4文件会沿用原文件名。</p> <h3><a name="t6"></a>2.3 某些flv文件转换成mp4时会报错，这时可尝试以下代码：</h3> <pre data-index="2"><code class="hljs language-r">ffmpeg <span class="hljs-operator">-</span>i filename.flv <span class="hljs-operator">-</span><span class="hljs-built_in">c</span><span class="hljs-operator">:</span>v libx264 <span class="hljs-operator">-</span>crf <span class="hljs-number">19</span> <span class="hljs-operator">-</span>strict experimental filename.mp4</code><div class="hljs-button {2}" data-title="复制" onclick="hljs.copyCode(event)"></div></pre> <p>第一个filename改为需要转换的文件名，第二个filename改为相应的输出文件名。</p> <h3><a name="t7"></a>*2.4 flv/mp4文件的合并</h3> <p>有时通过某些下载工具得到的flv/mp4文件被分为多个片段，但我们希望将它们合并。</p> <p>以合并5个mp4文件：</p> <p>文件1.mp4<br> 文件2.mp4<br> 文件3.mp4<br> 文件4.mp4<br> 文件5.mp4</p> <p>为例。</p> <p>新建一个txt文件，把需要合并的mp4文件的文件名依序写在txt文件中并保存，格式如下：</p> <pre data-index="3"><code class="hljs language-javascript"><ol class="hljs-ln" style="width:100%"><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">file <span class="hljs-string">'文件1.mp4'</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">file <span class="hljs-string">'文件2.mp4'</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">file <span class="hljs-string">'文件3.mp4'</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">file <span class="hljs-string">'文件4.mp4'</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="5"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">file <span class="hljs-string">'文件5.mp4'</span></div></div></li></ol></code><div class="hljs-button {2}" data-title="复制" onclick="hljs.copyCode(event)"></div></pre> <p>注：这里txt文件被命名为<span style="color:#38d8f0;"><strong>combine.txt</strong></span></p> <p>把上述需要合并的mp4文件和这个txt文件放在同一个文件夹下，然后在cmd中进入该文件夹，再输入以下命令：</p> <pre data-index="4"><code class="hljs language-lua">ffmpeg -f <span class="hljs-built_in">concat</span> -safe <span class="hljs-number">0</span> -i combine.txt -c copy <span class="hljs-built_in">output</span>.mp4</code><div class="hljs-button {2}" data-title="复制" onclick="hljs.copyCode(event)"></div></pre> <p>回车。即可得到一个完整的mp4文件。</p> <p>合并多个flv文件的方法类似。</p> <p></p> <p>输出的文件与原文件在同一文件夹中。</p>                </div><div><div></div></div>        </div><hr>]]></content>
    
    
    <categories>
      
      <category>教程</category>
      
      <category>视频编辑</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ffmpeg</tag>
      
      <tag>视频</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python编译so和pyd文件</title>
    <link href="/2022/07/18/python%E7%BC%96%E8%AF%91so%E5%92%8Cpyd%E6%96%87%E4%BB%B6/"/>
    <url>/2022/07/18/python%E7%BC%96%E8%AF%91so%E5%92%8Cpyd%E6%96%87%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<p>python代码即便是编译成pyc也同样可以被反编译，通常为了产品发布跟代码保护，会编译成so(linux)或者pyd(windows)。</p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>主要流程是，先调用Cython包将python代码编译成c代码，再将c代码编译成so文件跟pyd文件。由于使用了gcc，所以需要安装对应的build工具。在windows平台可以通过Visual Studio Installer安装对应的包。</p><p><img src="https://by3302files.storage.live.com/y4mjOIpaxoglVNQtOuyJU2tGo30SMw22C61fR1HgyecUZf0la_8_eL8U8OKQzzNEggffhOxJa6SBBgy1YHwVjIFxzJJW6R1_d2N31XVSWR5BQPmwT7rwHN5hEHfuJ0G2FzDMTOB64tHaNuhqKKu1P_m3qayydJIqX-5TD4Ndr2jFtIrm85rxeL1xYuxo6Rid2si?width=1278&height=686&cropmode=none" alt="Visual Studio Installer 配置C环境"></p><p>Linux 需要自行配置下c++生成工具。</p><h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><p>参考git项目<a href="https://github.com/HamzaAissaoui/PythonCompilerC">PythonCompilerC</a>，一大部分工作在于对目录结构的处理，而这个项目本身生成的so/pyd文件全部在对应的build_path下，原有的目录结构消失。并且，由于不同平台的命令行格式不一样，导致编译的时候出了很多bug。对此做了一些修改，具体项目参见<a href="https://github.com/Coldison/PythonCompile2So">PythonCompileSo</a>。</p><p>将本项目放到要编译的项目的目录下。注意项目中的<strong>init</strong>.py文件需要删掉，这部分编译会出现字符错误。</p><p>Windows平台：</p><figure class="highlight cmd"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cmd">python PROJECTPATH\scripts\compile.py --project-<span class="hljs-built_in">dir</span> PROJECTPATH --build-lib BUILDPATH<br></code></pre></div></td></tr></table></figure><p>Linux平台：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">python PROJECTPATH/scripts/compile.py --project-dir PROJECTPATH --build-lib BUILDPATH<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>教程</category>
      
      <category>python使用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>编译</tag>
      
      <tag>so</tag>
      
      <tag>pyd</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ArgParser的使用</title>
    <link href="/2022/07/13/ArgParser%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2022/07/13/ArgParser%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>命令行运行Python文件时，可以添加相应的参数。如：</p><figure class="highlight vim"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs vim"><span class="hljs-keyword">python</span> <span class="hljs-built_in">add</span>.<span class="hljs-keyword">py</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span><br></code></pre></div></td></tr></table></figure><p>在运行时，<code>from sys import argv</code>就可以读取命令行参数，通常是一个列表，此处的 <code>argv = [add.py, 1, 2]</code>。对于比较复杂的程序，使用这种方式读取命令行参数显然还是比较麻烦的。于是就引入了 <code>argparse</code>模块。具体可以参考官方文档：<a href="https://docs.python.org/3/library/argparse.html" title="argparse官方文档">Parser for command-line options, arguments and sub-commands</a></p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> argparse<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">parse_args</span>():</span><br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    :return:进行参数的解析</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    description = <span class="hljs-string">&quot;you should add those parameter&quot;</span>                   <span class="hljs-comment"># 步骤二</span><br>    parser = argparse.ArgumentParser(description=description)        <span class="hljs-comment"># 这些参数都有默认值，当调用parser.print_help()或者运行程序时由于参数不正确(此时python解释器其实也是调用了pring_help()方法)时，</span><br>                                                                     <span class="hljs-comment"># 会打印这些描述信息，一般只需要传递description参数，如上。</span><br>  <br>    parser.add_argument(<span class="hljs-string">&quot;-rp&quot;</span>, <span class="hljs-string">&quot;--replay_name&quot;</span>, default=<span class="hljs-string">&quot;test.zip&quot;</span>,<span class="hljs-built_in">type</span>=<span class="hljs-built_in">str</span>, <span class="hljs-built_in">help</span>=<span class="hljs-string">&quot;复盘名称&quot;</span>)<br>    parser.add_argument(<span class="hljs-string">&quot;-rv&quot;</span>, <span class="hljs-string">&quot;--redview_on&quot;</span>, action=<span class="hljs-string">&quot;store_true&quot;</span>, default=<span class="hljs-literal">False</span>, <span class="hljs-built_in">help</span>=<span class="hljs-string">&quot;是否是红方视角&quot;</span>)<br>    parser.add_argument(<span class="hljs-string">&quot;-s&quot;</span>, <span class="hljs-string">&quot;--scene&quot;</span>, <span class="hljs-built_in">type</span>=<span class="hljs-built_in">int</span>, default=<span class="hljs-number">20220621</span>, <span class="hljs-built_in">help</span>=<span class="hljs-string">&quot;想定编号&quot;</span>)<br>    parser.add_argument(<span class="hljs-string">&quot;-dp&quot;</span>, <span class="hljs-string">&quot;--data_path&quot;</span>, <span class="hljs-built_in">type</span>=<span class="hljs-built_in">str</span>, default=<span class="hljs-string">&quot;./logs/data/&quot;</span>, <span class="hljs-built_in">help</span>=<span class="hljs-string">&quot;解析数据路径&quot;</span>)<br>    parser.add_argument(<span class="hljs-string">&quot;-sc&quot;</span>, <span class="hljs-string">&quot;--scope_on&quot;</span>, action=<span class="hljs-string">&quot;store_true&quot;</span>, default=<span class="hljs-literal">False</span>, <span class="hljs-built_in">help</span>=<span class="hljs-string">&quot;是否解析视野&quot;</span>)<br>  <br>    parser.print_help()<br>    <span class="hljs-keyword">return</span> parser.parse_args()<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    args = parse_args()<br></code></pre></div></td></tr></table></figure><p>先给出一个例子。具体的流程是：</p><ul><li><p>先实例化一个 <code>ArgumentParser</code>可以添加描述。</p><ul><li>官方文档中还有其余的属性<br><img src="https://by3302files.storage.live.com/y4mJNjqUbkRtw0yibJEHVpamztvolm22ce2nFuZtxVZ1VgibrF8mFt7uTu8S6X0bUwu4MLGj3rt8bi2poj-A9BdaCKfHXgxhelLV3cagIaCpB8xdqqysD-zGisjV2LvIlWMmRYJtE9MM9EezEcqe7wOk5HP9UGGuh-GqBYm6Tv2uxBrieCXs9v3tuQEyo7aaU-J?width=817&height=524&cropmode=none" alt="ArgumentParser" title="ArgumentParser属性"></li></ul></li><li><p>然后调用 <code>add_argument</code>方法添加命令行选项<br><img src="https://by3302files.storage.live.com/y4maWV3d07DQSL5IGeVCVf7D4vdZuNyY-C-vBuLRdFcLDnlqzGs-ZJOWvZn1knE5MzNXk4jqMItmQncI6fsGnNycdxUQ-oeUzaTMmCe6xgn7rorPiraIFop-iOfNICje333kKrZR4TTAAhYr6sdoHoNQs0kR6kAAb95R4RddtSjjkbY5als1fbhwmMCQFEo6VH2?width=802&height=491&cropmode=none" alt="add_argument" title="add_argument方法 "></p><ul><li><p>name or flags用于识别参数选项，其中有-或者–前缀的是可选命令，如果不加前缀则是位置参数（positional argument) 如运行需要的文件名。</p><figure class="highlight python-repl"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python-repl"><span class="hljs-meta">&gt;&gt;&gt;</span> <span class="python">parser = argparse.ArgumentParser(prog=<span class="hljs-string">&#x27;PROG&#x27;</span>)</span><br><span class="hljs-meta">&gt;&gt;&gt;</span> <span class="python">parser.add_argument(<span class="hljs-string">&#x27;-f&#x27;</span>, <span class="hljs-string">&#x27;--foo&#x27;</span>)</span><br><span class="hljs-meta">&gt;&gt;&gt;</span> <span class="python">parser.add_argument(<span class="hljs-string">&#x27;bar&#x27;</span>)</span><br><span class="hljs-meta">&gt;&gt;&gt;</span> <span class="python">parser.parse_args([<span class="hljs-string">&#x27;BAR&#x27;</span>])</span><br>Namespace(bar=&#x27;BAR&#x27;, foo=None)<br><span class="hljs-meta">&gt;&gt;&gt;</span> <span class="python">parser.parse_args([<span class="hljs-string">&#x27;BAR&#x27;</span>, <span class="hljs-string">&#x27;--foo&#x27;</span>, <span class="hljs-string">&#x27;FOO&#x27;</span>])</span><br>Namespace(bar=&#x27;BAR&#x27;, foo=&#x27;FOO&#x27;)<br><span class="hljs-meta">&gt;&gt;&gt;</span> <span class="python">parser.parse_args([<span class="hljs-string">&#x27;--foo&#x27;</span>, <span class="hljs-string">&#x27;FOO&#x27;</span>])</span><br>usage: PROG [-h] [-f FOO] bar<br>PROG: error: the following arguments are required: bar<br></code></pre></div></td></tr></table></figure></li><li><p>action是指接受参数之后要执行的动作，通常是 <code>store_false</code>，<code>store_true</code>或者 <code>store_const</code>，不需要接受其余参数，直接将对应的选项变量保存为特定的值。这是使用得比较多的选项。<code>append</code>是一个特殊的action，它会将参数追加到列表中。<code>count</code>是一个特殊的action，它会将参数计数，并将计数值保存到变量中。</p></li><li><p>其他还有一些方法这里就不再赘述了，具体使用的时候可以参考官方文档。</p></li></ul></li><li><p>最后调用 <code>parse_args</code>方法解析命令行参数，返回一个 <code>Namespace</code>对象，其中包含了所有的参数。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>教程</category>
      
      <category>python使用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>argparse</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker build中的常见错误及常用命令(未完)</title>
    <link href="/2022/06/24/Docker%E5%AE%89%E8%A3%85%E4%B8%8E%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E6%93%8D%E4%BD%9C%E4%B8%8E%E9%97%AE%E9%A2%98/"/>
    <url>/2022/06/24/Docker%E5%AE%89%E8%A3%85%E4%B8%8E%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E6%93%8D%E4%BD%9C%E4%B8%8E%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>Docker安装和从docker file build网上应该有教程，这里记录一下我自己在安装pymarl所遇到的一些问题及一些常用命令。目前只写了一点点，后续会继续在这篇博文之中添加。</p><h3 id="一-常用命令"><a href="#一-常用命令" class="headerlink" title="一. 常用命令"></a>一. 常用命令</h3><p>   docker删除镜像：</p><ol><li><p>删除容器</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">docker ps <span class="hljs-comment">#查看正在运行的容器</span><br><br>docker ps -a <span class="hljs-comment">#查看所有容器</span><br><br>docker rm container_id <span class="hljs-comment">#删除容器</span><br></code></pre></div></td></tr></table></figure></li><li><p>删除镜像</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">docker images //查看镜像<br><br>docker rmi image_id<br><span class="hljs-comment"># 删除 null image</span><br><br>sudo docker rmi $(docker images -f <span class="hljs-string">&quot;dangling=true&quot;</span> -q) <span class="hljs-comment">#删除所有镜像</span><br><br><span class="hljs-comment"># 删掉容器</span><br>docker stop $(docker ps -qa)<br>docker rm $(docker ps -qa)<br><br><span class="hljs-comment"># 删除镜像</span><br>docker rmi --force $(docker images -q)<br><br><span class="hljs-comment"># 删除名称中包含某个字符串的镜像</span><br><span class="hljs-comment"># 例如删除包含“some”的镜像</span><br>docker rmi --force $(docker images | grep some | awk <span class="hljs-string">&#x27;&#123;print $3&#125;&#x27;</span>)<br></code></pre></div></td></tr></table></figure><h3 id="二-常见错误"><a href="#二-常见错误" class="headerlink" title="二. 常见错误"></a>二. 常见错误</h3></li><li><p>debconf: delaying package configuration, since apt-utils is not installed是说<code>apt-utils</code> 没有安装，对结果并没有什么危害，只是影响交互式安装。这个<code>apt-utils</code> 可以实现在安装过程中交互式配置文件，可以通过：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">RUN apt-get install --assume-yes apt-utils<br></code></pre></div></td></tr></table></figure><p>忽略掉这个警告信息。</p></li><li><p>InRelease:InRelease: The following signatures couldn’t be verified because the public key is not available</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys　425956BB3E31DF51<br>sudo apt update<br></code></pre></div></td></tr></table></figure><p>如果不行的话可以尝试在docker file中添加，<code>RUN rm/etc/apt/sources.list.d/cuda.list</code></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>教程</category>
      
      <category>Docker使用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PSRO笔记</title>
    <link href="/2022/06/20/PSRO%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/06/20/PSRO%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p><a href="https://arxiv.org/pdf/1711.00832.pdf">PSRO</a>这篇文章看了很久还是看不懂，慢慢做点笔记。</p><p>最简单最传统的多智能体即为InRL，即为每个智能体分别独立训练，但是会遇到不稳定（non-stationary）及非马尔科夫（non-Markovian)。非马尔科夫性我的理解即为，上一轮训练收敛的策略与下一轮训练没有确定的相关性，这一点也跟不稳定相对应。在这种情况下，训练只会得到相互过拟合的智能体，没有办法获得泛化的能力。</p><p>本文提出了一种独立学习产生的策略之间相关性的度量方式，并且证明了过拟合问题的严重性。给出的算法应该是从一系列的策略分布中选出得出一个混合策略。</p><blockquote><p>中心化训练分布式执行：</p><ul><li>Fully Decentralized: 去中心化，每个agent是独立的个体，彼此之间不交流</li><li>Fully Centralized: 完全中心化，所有agent都把信息传递给中央控制器central controller，中央控制器指导所有agents的动作、状态以及奖励。agent自己没有策略网络（不做决策），决策都由中央控制器来做。</li><li>Centralized training and decentralized execution：agents各自有各自的策略网络，训练的时候有一个中央控制器，它会收集所有agents的动作、状态以及奖励。中央控制器帮助agents训练策略网络，训练结束之后就不再用中央控制器了。每个agents根据自己的策略网络做决策。</li></ul><p>作者：凌晨一點钟的猫<br>链接：<a href="https://zhuanlan.zhihu.com/p/331722990">https://zhuanlan.zhihu.com/p/331722990</a></p></blockquote><blockquote><p>正则形式的博弈(Normal-form game):</p><p>正则形式是博弈论中描述博弈的一种方式。与扩展形式的博弈（extensive form game）不同，正则形式不用图形来描述博弈，而是用矩阵来陈述博弈。与延展形式的表述方式相比，这种方式在识别出严格优势策略和纳什均衡上更有用，但会丢失某些信息。博弈的正则形式的表达中包括每个参与者所有显然的和可能的策略，以及和与其相对应的收益。</p><p>在完全信息的静态博弈（static games of complete，perfect information）中，正则形式的表达形式是参与者的策略空间（strategy space）和收益函数（payoff function）。策略空间是某个参与者的所有可能策略的集合而策略是参与者在博弈的每个阶段——不管在博弈中这个阶段实际上是否会出现——将要采取的行动的完整计划。每个参与者的收益函数，是从参与者策略空间的向量积到该参与者收益集合（一般是实数集，数字表示基数效用或序数效用——在正则形式的表述方式中常常是基数效用）的映射。也就是说，参与者的收益函数把策略组合（所有参与者策略的清单）作为它的输入量，然后输出参与者的收益。</p></blockquote><blockquote><p>博弈论中，与正则形式相对应，扩展形式是一种通过树来描述博弈的表达方式。每个节点（称作决策节点）表示博弈进行中的每一个可能的状态。博弈从唯一一个初始节点开始，通过由参与者决定的路径到达终端节点，此时博弈结束，参与者得到相应的收益。每个非终端节点只属于一个参与者；参与者在该节点选择其可能的行动，每个可能的行动通过边从该节点到达另一个节点。和正则形式不同，扩展形式允许互动的显式模型（explicit modeling of interactions），互动中，一个参与者可以在博弈中多次行动，并且在不同的状态中可以做出不同的行为。</p></blockquote><p>正则形式的博弈可以看作，所有参与者的行动是同时作用在系统上的，所以可以建立收益矩阵，而扩展形式的博弈则参与者是交替参与（动态博弈）。关于子博弈的理解：<a href="https://www.zhihu.com/question/27102628/answer/35440374">如何从博弈树中划分出各个子博弈？贝叶斯法则如何使用？</a></p><p>PSRO的思想为，对于正则形式的博弈，采用其他智能体的元策略来训练本智能体的近似最佳反应，也即固定其余智能体的现有策略（未必是一个）来训练本智能体。因为不是共同进化，所以才叫做近似最佳反应（approximate best response)。得出的本智能体的策略再加入策略集合去训练其余智能体。DCH则更进一步，将智能体划分为k个阶段并行训练。，最终得到满足纳什均衡的各方策略。作者使用了PRD（projected replicator dynamics），给定一个智能体策略池中选取某策略的最低概率，从而强化探索。</p><p>本文与我想做的多智能体RTS想去甚远，但是对于对抗游戏而言，可以借鉴本文的训练方式，思考如何在扩展形式的博弈中求得纳什均衡。</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>强化学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RL</tag>
      
      <tag>ML</tag>
      
      <tag>MARL</tag>
      
      <tag>PSRO</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>劳动节随笔二零二二</title>
    <link href="/2022/04/22/%E5%8A%B3%E5%8A%A8%E8%8A%82%E9%9A%8F%E7%AC%94%E4%BA%8C%E9%9B%B6%E4%BA%8C%E4%BA%8C/"/>
    <url>/2022/04/22/%E5%8A%B3%E5%8A%A8%E8%8A%82%E9%9A%8F%E7%AC%94%E4%BA%8C%E9%9B%B6%E4%BA%8C%E4%BA%8C/</url>
    
    <content type="html"><![CDATA[<p>一</p><p>I’ve long been trapped in a circle of fighting against myself. Up till now, still I have no idea why things falled in such a rush. With no bravery to expose the trouble of myself, I swallowed the pill of escapism and maybe some cynicism as a transitory and illusory relief. In a way, it is equivalent to the confession of personal failure. Or even worse, it’s distorted by this gloomy era where people with no faith couldn’t breathe. It’s intensified from a perspective of some random or once hard-working small-town guy gradually get a glance of the ruthless operation mechansim of Chinese society. It’s disturbed by the huge obstacles standing in between traditional parenting full of emotional abuse, high requirements and nearly no postive response and modern education. The first one pictures a gray future for everyone. The second one only tells a more hopeless story about alienation of human-beings by so-called capitalism or other cults. If the age of 21 century devours future, the last one is about the past with extra meaningless tolerance towards poverty or feelings about unsafety or conflicts within traditional Chinese families. Here, I am not to say, it is all because of such a miserable objective outside world so that I couldn’t stand anymore. No, things are not working like that. I know many etraordinary people who dare to overcome all kinds of sufferings. More or less, there may be a generation of the species who resist and win. They set a perfect example for me as well. However, the key-point is, such negative environment changes my mind eternally.</p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>劳动节</tag>
      
      <tag>2022</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于女权的一点看法</title>
    <link href="/2021/04/04/%E5%85%B3%E4%BA%8E%E5%A5%B3%E6%9D%83%E7%9A%84%E4%B8%80%E7%82%B9%E7%9C%8B%E6%B3%95/"/>
    <url>/2021/04/04/%E5%85%B3%E4%BA%8E%E5%A5%B3%E6%9D%83%E7%9A%84%E4%B8%80%E7%82%B9%E7%9C%8B%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>关于女权的讨论，于我而言应该是要翻篇了，就像之前的种种思潮，情绪过去后留下的便是垃圾时间，不管如何不眠不休，于问题本身是没有任何助益了。在公开平台发表过一些言论，为此也许颇伤了某一些女性网友的内心，使其知道在这个问题上性别始终是我们之间巨大的鸿沟。这也是我有意为之，我很感谢她们能够表达出自己内心的观点，而我也这么做，无非是在构筑一种景观，多提供一种角度，无论鄙夷，终究会有更全面的认识。以下算是一些毫无逻辑关联的存档：</p><a id="more"></a><h4 id="（一-女性与现代性"><a href="#（一-女性与现代性" class="headerlink" title="（一)  女性与现代性"></a>（一)  女性与现代性</h4><p>就我个人经历而言，女性通过婚姻从县城跃迁到大城市远远比男性要来得容易得多。有大家族的同学们不妨对比一下表兄弟与表姐妹的境遇差距。</p><p>我想，这已经算是一个很明显的Pattern了。通过婚姻关系，女性从边缘地区向中心靠近，同时男性的择偶标准也通常会把落后地区的女性纳入考量而不是更先进的地区。</p><p>这一性别差异以国别的方式表现出来更为明显，嫁给日本籍与娶日本籍的比例大概是100比1。</p><p>把女性的流动作为现代性的度量。县城或者农村显然被认为是保守/不尊重女性/封建/落后的地方，知乎上有很多这样的事例作为见证。</p><p>对于资本主义世界而言，这里的现代性显然是与阶级地位，与金钱紧密相连的。</p><p><img src="https://bn1305files.storage.live.com/y4maTaZYLuiI8_wPO0DZEU-w2njFySK6sBe86QSs5YhO2Mx_7zo3-5n3BsIgnb8FwTeuFARDEVGDI3kmtgeM1RiEwuId9P-9UacddUgc256lVojo0CJx7oITVEPJaBSGZPDFJzSDj2Y93wObdp-pghfpdKy_I9W1nrnLlEr2nvnMQ8KDX6d7kuTyQoOp5zye3JF?width=566&height=666&cropmode=none" alt="性别金字塔"></p><h4 id="（二）脱口秀、女权与我"><a href="#（二）脱口秀、女权与我" class="headerlink" title="（二）脱口秀、女权与我"></a>（二）脱口秀、女权与我</h4><p>如果去看德云社的访谈，就会发现人家很自知，喜剧的第一要务是搞笑而不是教育群众。Ronny Chieng跟Jimmy Oyang的聊天还有其他的一些对谈，都会谈到在创作时的克制，不必跟不相关的受众谈他们不了解的东西，而如果要谈，那就一定是相当重要，比如日本在新加坡与马来西亚的所作所为。</p><p>再对女权主义表一下态，通常我会把女性所受到的压迫放到更大一点的图景去看，也即性别权力实际上是阶级权力的一种投射，换一句话来说，性别跟阶级结合才会产生压迫。如果一位女性利用性别与领导产生不正当关系上位，那么她是受到压迫还是没有受到压迫，领导与她的同事又是怎样的情形。不可否认，有相当多的女性受到无穷尽的性骚扰或者家庭暴力或者有关种种。但是我们同样也不能否认，在比如中国的婚姻关系中女性的性别会带来某种加成。天底下只有凤凰男，怎么会有凤凰女呢。——如果认识不到这样的一种现实，那么平权运动本身差不多是在缘木求鱼。</p><p>再谈两点。第一点是某一种滑坡谬误，女性受到了广泛的压迫，于是需要系统性地补偿，与此同时，如果女性取得了显著的优势，那么这显然是女性天生高人一等，这一论点被大量运用。第二点是，但凡谈及农村男性，封建保守等等一系列批判接踵而至。而从毛主席的思想来看，最重要的是人的改造。譬如，因为大凉山区的同胞有种种陋习，就因此抛弃他们，放弃扶贫嘛。所谓的白人至上主义，差不多就是社会工程失败的结果。白右红脖子一方面宗教保守，一方面穷困潦倒，这不是我们社会主义国家应该重蹈的覆辙。</p><p>很长一段时间内我大概会持有如下的原则：性别不同是一个生物学事实（会有达尔文主义者跑过来谈两条x染色体的高贵）；同工同筹，即从事同样的劳动付出同样的时间/生物学能量应该获得同样的报酬，不是同岗位也不是同行业，而是同工同筹；妇女权益比如产假之类的也同样予以男性支持，如果只有一方可以享受产假，那么在用人市场上当然会出现不平等。</p><p>不过我对于未来的走向是悲观的，政治的极化在所难免。从现在的统计数据以及我自己的所见所闻来看，美利坚差不多是我们的宿命。——杨笠差不多仅仅是混沌中的浪花罢了。</p><p>实际上并不仅仅是我，从能够接触到的精英们来看，悲观的也要多于乐观的。这里谈的并不是中美的问题，而是中国社会本身的演化，人类本身的前途命运。美利坚所经历的种种窠臼或许我们也将同样经历，而美利坚之后，颠簸前行，我们也再无答案。</p><h4 id="（三）性别金字塔的一个例子"><a href="#（三）性别金字塔的一个例子" class="headerlink" title="（三）性别金字塔的一个例子"></a>（三）性别金字塔的一个例子</h4><p><img src="https://bn1305files.storage.live.com/y4mkhm7tbFnrz3wHXQh81owVuX62OA_b3CxMRDR1JTkAHk5z0S8zZnDVfEAmIbcHUPHR0zSCTfErfqICehoSiUMBCgj1jklQ9vaYTZwz--2angVxT-IYilTP11a6dLaU-iSwAaOEQcdkvWnFoIxRo32cEOjEFMA8BFWLAKMiJmi2Dqq4YYPGOFRmGYIFDuoyBoa?width=837&height=1024&cropmode=none" alt="性别压迫的传播"></p><p>这里批判的是我最喜欢的fleabag，但是实际上这整个讨论串主要是亚裔女性抱怨在日常生活中会更容易遭到白人女性的莫名其妙的嫉妒与打压，这些女同志的自我解释为因为亚裔女性更为优秀，更具有性吸引力。</p><p>但是这大概是我的金字塔的一个充分的例子了，白人男性有Asian Fetish，脱口秀笑话也讲白人男性跟亚裔男性的共同特点就是有亚裔老婆，这确实是很普遍的现象。于是优秀的亚裔女性通过选择白人男性对普通且自信的白人女性造成了压迫。而Asian Fetish形成的原因大概是优秀的白人女性通过种种运动极大的拉高了择偶门槛与其中的各种风险，亚裔女性通常被视为安全、顺从、non-aggressive，白垃圾专门钓easy girl的也不少，最近看的曹紫媛差不多已经被洗脑成人形牲口了。总而言之Asian Fetish的出现不仅仅是亚洲人的文化特质，同样也跟这些运动社会风气密切相关。再回过头来，女性争取平权运动就一定是错误嘛，当然不是。澳大利亚国会性侵案仍然在发酵当中，这算是直接的证明。于是问题来到了掌握权力的男性，也就是顶层的alpha-male。</p><p>实际的情况比上述的分析还要复杂。但是我们应该可以清晰地看到，压迫并不是简单的二元对立，而是有一段相当长的传播链，其中的主要量度应该是社会经济地位，其中的社会一般会滞后于经济变化。</p><h4 id="别语"><a href="#别语" class="headerlink" title="别语"></a>别语</h4><p>我决心在未来跳脱出这一话题的讨论，因为在这一问题上似乎我开始有一点马基雅维利的倾向。而且我更知道，互联网上的波澜远远不能刻画现实世界，尤其是不同阶层的所感所想，所遭受的痛苦。时间是检验一切的最好量度，而目前的这一切看起来的确像是一场盛大的cosplay——一场祭祀的cosplay，其如果真能召唤出古神，那么我也只好尽力让它从哪里来回到哪里去了。</p>]]></content>
    
    
    <categories>
      
      <category>评论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>女权</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于2021的一点想法</title>
    <link href="/2021/03/01/%E5%85%B3%E4%BA%8E2021%E7%9A%84%E4%B8%80%E7%82%B9%E6%83%B3%E6%B3%95/"/>
    <url>/2021/03/01/%E5%85%B3%E4%BA%8E2021%E7%9A%84%E4%B8%80%E7%82%B9%E6%83%B3%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>也算是已经工作了近五个月，现在来谈一谈自己的感想。实际上我对于这份工作还是感激的成分比较多，因为彼时的我仍然处于抑郁的状态，行动力极其有限。有这么一个机会能够脱离家庭环境进入社会环境，对我来说算是一个小小的转折 。不过显然，如果当初去了体制内，或许结果会更加的不同。总而言之，在这短短的5个月里，似乎是看西洋景一般，体验到了很多新奇的经历，证明了自己总算是还没有退化，可以承担一些任务。</p><a id="more"></a><p>但是同时也感受到自身明显的缺陷——这不奇怪，毕竟我本来就是什么也不会。在工作中。</p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>新年</tag>
      
      <tag>蒲草集</tag>
      
      <tag>计划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>回乡偶记</title>
    <link href="/2021/02/19/%E5%9B%9E%E4%B9%A1%E5%81%B6%E8%AE%B0/"/>
    <url>/2021/02/19/%E5%9B%9E%E4%B9%A1%E5%81%B6%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="（一）"><a href="#（一）" class="headerlink" title="（一）"></a>（一）</h3><p>故乡也无非是这样。几般琐事，各自凉薄。独自在街道上夜游了很久，过公园大门而折返，又去看郎川。新年里灯光晦暗，流水汩汩。这里从前定有夜渔的人。我甚至能够想象，旧年的正月，人们正是在此游船互访，星月点点，这河运码头连着老街，送往迎来，喧嚣异常。</p><p>有一段时间想去翻建平史料，也在油管看到日本兵进城的段落。山川风物，历史典故，相较桑梓，我所知也绝不为少。然而说不清楚，道不分明。我并不知悉这里的十万家灯火，其与我也永远不会生出任何干系。以某种怀疑论的姿态来看，我之所爱，也无非是某种习惯，某些记忆。又或者仅仅是对北京的不爱罢了。</p><p>在街头徘徊而无所适从，也会觉得，乡土中国自有其魅力，传统形成了强而有力的势场，塑造着人们的一举一动，也由此形成极其复杂而稳健的社会动力学系统。其精巧，其严密，的确每每在某一时刻令人安心。</p><p>不过这显然也是极大的耗费。我从来不啻于谈及人类的粗鄙与卑劣，不吝于表达对人类社会的失望与嘲讽。这系统能够给人带来幸福，当然也就带来痛苦。烦难之处在于，这既是一种社会意识，也是一种社会无意识。仅仅通过各种不幸，我们能够勾勒出其边界，将其作为某种更为普遍的结构。然后将这种种，淹没在经文与诗颂当中。</p><p>我本人自是离经叛道的人，一面觉得可笑，另一面也因此孤僻起来。随意地发些感慨，一切皆为法，如梦幻泡影。 如露亦如电，应作如是观。</p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>新年</tag>
      
      <tag>蒲草集</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>WSL安装及用miniconda创建python3.7环境</title>
    <link href="/2021/02/07/WSL%E5%AE%89%E8%A3%85%E5%8F%8A%E7%94%A8miniconda%E5%88%9B%E5%BB%BApython3-7%E7%8E%AF%E5%A2%83/"/>
    <url>/2021/02/07/WSL%E5%AE%89%E8%A3%85%E5%8F%8A%E7%94%A8miniconda%E5%88%9B%E5%BB%BApython3-7%E7%8E%AF%E5%A2%83/</url>
    
    <content type="html"><![CDATA[<p>WSL在windows上的确相当的鸡肋，但是假若没有配置服务器，WSL配合VSCode，也可以充当生产力工具。比较大的bug是，WSL的文件与NTFS的文件系统并不同步，可能是创建了多个缓存，因此需要不断地Reload来更新。如果有服务器资源或者Linux桌面版，那么配合VSCode远程开发工具就已经很香了。以下是WSL的安装教程。</p><a id="more"></a><h3 id="1-WSL准备"><a href="#1-WSL准备" class="headerlink" title="1. WSL准备"></a>1. WSL准备</h3><p>参考文章：<a href="https://zhuanlan.zhihu.com/p/104060131">vscode wsl入门 - tnnmigga的文章 - 知乎</a></p><ul><li><p>首先要在windows打开linux子系统功能<br>控制面板——程序——启用或关闭windows功能——适用于linux的windows子系统</p></li><li><p>然后重启电脑</p></li><li><p>打开win10应用商店，搜索Ubuntu</p></li><li><p>下载安装好后启动，可以看到Ubuntu bash， 几分钟后初始化完成（这里没有提示，几分钟后按Enter键）即可。输入用户名: dison （不能有大写字母，这里dison用于用户指代，可以输自己的名字）及密码。</p></li><li><p><code>&lt;u&gt;</code>如果不喜欢用Ubuntu自带的bash的话可以使用Pycharm或者vscode的terminal，方便代码的复制粘贴。直接在terminal中输入wsl或者Ubuntu就可以打开Ubuntu子系统 <code>&lt;/u&gt;</code></p></li><li><p>换源</p><ul><li><p>获取权限</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">sudo chown -R dison /etc/apt/sources.list<br></code></pre></div></td></tr></table></figure></li><li><p>备份原文件</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">sudo cp /etc/apt/sources.list /etc/apt/sources.list.bak<br></code></pre></div></td></tr></table></figure></li><li><p>编辑源</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">sudo vim /etc/apt/sources.list<br></code></pre></div></td></tr></table></figure><p>打开sources.list后按i键进入insert模式，将原来的源都用#注释掉。（如果会使用vim编辑器可以使用其他的快捷键）</p><p>复制下面的源：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释</span><br>deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal main restricted universe multiverse<br><span class="hljs-comment"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal main restricted universe multiverse</span><br>deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-updates main restricted universe multiverse<br><span class="hljs-comment"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-updates main restricted universe multiverse</span><br>deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-backports main restricted universe multiverse<br><span class="hljs-comment"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-backports main restricted universe multiverse</span><br>deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-security main restricted universe multiverse<br><span class="hljs-comment"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-security main restricted universe multiverse</span><br><br><span class="hljs-comment"># 预发布软件源，不建议启用</span><br><span class="hljs-comment"># deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-proposed main restricted universe multiverse</span><br><br><span class="hljs-comment"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-proposed main restricted universe multiverse</span><br></code></pre></div></td></tr></table></figure><p>光标移到最下方右键单击粘贴源。</p></li></ul><p>按Esc键退出编辑模式，依次输入 :wq保存更改。</p><ul><li>更新源文件</li></ul><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">sudo apt update<br></code></pre></div></td></tr></table></figure><h3 id="2-安装miniconda"><a href="#2-安装miniconda" class="headerlink" title="2. 安装miniconda"></a>2. 安装miniconda</h3></li></ul><p>参考文章：<a href="https://blog.csdn.net/weixin_30486037/article/details/97982277">在Ubuntu上安装Miniconda</a></p><ul><li><p>下载并安装</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">sudo apt-get install wget<br>wget https://repo.anaconda.com/miniconda/Miniconda3-latest-Linux-x86_64.sh<br>bash Miniconda3-latest-Linux-x86_64.sh<br></code></pre></div></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 一直按回车然后输入yes</span><br>please answer <span class="hljs-string">&#x27;yes&#x27;</span> or <span class="hljs-string">&#x27;no&#x27;</span>:<br>&gt;&gt;&gt; yes<br><br><span class="hljs-comment"># 选择安装路径, 文件名前加点号表示隐藏文件</span><br>Miniconda3 will now be installed into this location:<br>&gt;&gt;&gt; ~/.miniconda3<br><br><span class="hljs-comment"># 添加配置信息到 ~/.bashrc文件</span><br>Do you wish the installer to initialize Miniconda3 by running conda init? [yes|no]<br>[no] &gt;&gt;&gt; yes<br></code></pre></div></td></tr></table></figure></li><li><p>运行配置信息文件</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">source</span> ~/.bashrc<br></code></pre></div></td></tr></table></figure></li><li><p>测试是否安装成功</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">conda --version<br></code></pre></div></td></tr></table></figure></li><li><p>如果是服务器用户，可以在Miniconda文件夹同目录下创建.condarc文件增加如下channel：</p><figure class="highlight json"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs json">channels:<br>  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/pytorch/<br>  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/<br>  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/<br>  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge/<br>ssl_verify: true<br><br></code></pre></div></td></tr></table></figure><p>也可以用如下命令添加源。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/pytorch/<br></code></pre></div></td></tr></table></figure><h3 id="3-python3-7及相关包安装"><a href="#3-python3-7及相关包安装" class="headerlink" title="3. python3.7及相关包安装"></a>3. python3.7及相关包安装</h3></li><li><p>如果已经进入了base环境可以用如下命令退出环境</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">conda deactivate<br></code></pre></div></td></tr></table></figure></li><li><p>创建python3.7环境</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">conda create -n venv python=3.7<br></code></pre></div></td></tr></table></figure></li><li><p>激活虚拟环境</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">conda activate venv<br></code></pre></div></td></tr></table></figure></li><li><p>安装相关包</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">conda install pandas<br>conda install pika<br>conda install pymysql<br>conda install xlrd=1.2.0<br>conda install matplotlib<br>conda install openpyxl<br>conda install pytorch torchvision torchaudio cudatoolkit=10.2 -c pytorch<br></code></pre></div></td></tr></table></figure><h3 id="4-运行说明"><a href="#4-运行说明" class="headerlink" title="4.运行说明"></a>4.运行说明</h3></li><li><p>路径说明</p><p>WSL能够运行Windows系统中的文件，需要在路径前加上/mnt，比如切换到D盘即为</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /mnt/d<br></code></pre></div></td></tr></table></figure></li><li><p>由于.so文件使用了python3.7编译，因此在运行程序前先激活python3.7环境，然后再运行相关脚本</p><figure class="highlight applescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs applescript">conda <span class="hljs-built_in">activate</span> venv<br></code></pre></div></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>教程</category>
      
      <category>Linux使用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>WSL</tag>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>勃学：成功人士的最后一次失败</title>
    <link href="/2021/02/07/%E5%8B%83%E5%AD%A6%EF%BC%9A%E6%88%90%E5%8A%9F%E4%BA%BA%E5%A3%AB%E7%9A%84%E6%9C%80%E5%90%8E%E4%B8%80%E6%AC%A1%E5%A4%B1%E8%B4%A5/"/>
    <url>/2021/02/07/%E5%8B%83%E5%AD%A6%EF%BC%9A%E6%88%90%E5%8A%9F%E4%BA%BA%E5%A3%AB%E7%9A%84%E6%9C%80%E5%90%8E%E4%B8%80%E6%AC%A1%E5%A4%B1%E8%B4%A5/</url>
    
    <content type="html"><![CDATA[<p>在去年三月我曾经对勃学发表了一番小小的意见，虽然无甚价值，但是修复了博客，重新上传一下：</p><a id="more"></a><blockquote><p>尽管勃学在知乎已经消退很久了，但是一直关注着这个小小的亚文化。在批判前首先要说明的是，作为一种亚文化，勃学的什么吸引着我们？毫无疑问，失败是勃学的核心。浅色床单，浙江大学，或者没有去牛组，或者最后做CS，在勃学语境中，被赋予失败的涵义。与之相对，去清北，去北美top10，去牛组，去大公司，做出fancy的成果，拿到相应的回报，便是勃学语境下的成功。他们本以为是唾手可得的，早就设想好的，却在咫尺之间分道扬镳，因为某一个选择，因为现实条件，客观因素，人生进入了“失败组”，并且就此断定，失败是永恒的，成功不过是那些有着更好家世背景，social network，或者八面玲珑，收割韭菜的产物。</p><p>不论如何定义成功和失败，失败是永恒的这个论断，首先是残酷现实的。正因为如此，当年轻人遭遇到了第一次失败的时候，会欣然投入勃学的怀抱——我也有错，但是世界当然也有错。承认并且拥抱失败，这是勃学给我们的积极暗示，是勃学的元命题。这个结论，堪比加缪的荒谬哲学。就像荒谬哲学只能进入意识到世界荒谬本质的人的脑海中一样，勃学对于失败者的迎合，是这个亚文化得以不断生长的原动力。</p><p>但是仅此而已，或许是缺乏社交媒体的传播，使得勃学在本质上变成了某种私密的价值观。除了失败是永恒的这一论断以外，勃学的其他阐述都仅仅依赖于勃学家们个人的生命体验。比如，在湾区当码农，年入百万，对勃学家们是失败，但是对绝大多数人来说当然是成功了。而在勃学家们的言谈举止中他们其实也不讳言这一点，他们已经得到了世俗意义的成功。比如立党会去假扮美国底层，但是他也会神气十足地说他在休斯敦最好的区。“我得到了很多，但是我失去的更多。”这大概是他们的失败逻辑。诡辩当然是可以的，毕竟这是他们真实的经历，他们的朋友同事同学都成功了，而他们则失败了。但是正因为这些经验本身，注定了勃学和勃学家们是缺乏关怀的。当曾勃自嘲三本的时候，绝对不会把三本放在眼里，同样，立党和美国底层也相去甚远。他们假扮着骑士，来揭穿欺骗韭菜的幌子，来传布勃学的真谛，但是这并不意味着他们关怀韭菜。梁山泊的好汉们要替天行道，但是杀起人来不也毫不手软嘛。缺乏关怀本身是勃学的致命弱点，这既是勃学无法被更多人接纳的原因，也是勃学家们自相矛盾的所在。明明为世界上最大的镰刀工厂服务，却鄙视起别的镰刀来。</p><p>勃学的第二个弱点在于解方，表面上勃学的终极结论是“自杀”，但是实际上勃学家个个都学着杨朱的法子，贵己重生。</p></blockquote><p>一年已经过去了，在这一年里很多都已经改变，包括勃学本身。事实上我也是最近才认识到，勃学早就已经死了，徐白左江，信徒不过是江湖故事，曾博也退化成互联网上的一只猫。我也不过在评论一堆废墟罢了。但是相比于一年以前，我已经不再讨厌他了。恰恰相反，我看到了一种坦诚。人不能欺骗别人，但首先不能欺骗自己。大众媒体侵蚀我们的生活，左右我们思想的时候，可能只有依靠这样的方法论，我们才能够真正接触到现实世界。浅色床单上的眼泪是真的，尽管也许故作姿态，但是我们也不能否认这一点。</p>]]></content>
    
    
    <categories>
      
      <category>评论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>勃学</tag>
      
      <tag>失败</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo的安装及使用</title>
    <link href="/2021/02/07/Hexo%E7%9A%84%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8/"/>
    <url>/2021/02/07/Hexo%E7%9A%84%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>本文主要介绍一下Hexo的安装与使用流程，以免自己忘记。</p><a id="more"></a><h3 id="一、Hexo的安装"><a href="#一、Hexo的安装" class="headerlink" title="一、Hexo的安装"></a>一、Hexo的安装</h3><h4 id="1-Hexo的安装"><a href="#1-Hexo的安装" class="headerlink" title="1. Hexo的安装"></a>1. Hexo的安装</h4><p>需要先安装nodejs以及git。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">npm install -g hexo-cli<br></code></pre></div></td></tr></table></figure><h4 id="2-Hexo的初始化"><a href="#2-Hexo的初始化" class="headerlink" title="2. Hexo的初始化"></a>2. Hexo的初始化</h4><p>Hexo安装完成后，在指定文件夹下初始化。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">hexo init &lt;folder&gt;<br><span class="hljs-built_in">cd</span> &lt;folder&gt;<br>npm install<br></code></pre></div></td></tr></table></figure><p>_config.yml下有网站的配置信息，可以在此配置大部分参数。具体配置及相关文档参见：<a href="https://hexo.io/zh-cn/docs/">Hexo文档</a></p><p>在github上创建名为<code>username.github.io</code>的仓库，在_config.yml文件的deploy部分配置自己的git仓库地址，将分支改为master。</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">deploy:</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">git</span><br>  <span class="hljs-attr">repo:</span> <span class="hljs-string">https://github.com/Coldison/coldison.github.io.git</span><br>  <span class="hljs-attr">branch:</span> <span class="hljs-string">master</span><br></code></pre></div></td></tr></table></figure><h3 id="二、Fluid主题配置"><a href="#二、Fluid主题配置" class="headerlink" title="二、Fluid主题配置"></a>二、Fluid主题配置</h3><p>我选择的是fluid主题，参见<a href="https://hexo.fluid-dev.com/docs/start/#%E4%B8%BB%E9%A2%98%E7%AE%80%E4%BB%8B">Fluid 主题文档</a>。</p><p>将Fluid主题文件解压，放到themes目录下并且改名fluid。在<code>_config.yml</code>中将theme改为fluid。然后将fluid文件夹下的 <code>_config.yml</code>改名为<code>_config.fluid.yml</code>，复制到<code>_config.yml</code>同级文件夹。然后就可以在<code>_config.fluid.yml</code>修改相应的style了。</p><p>主要是修改配色，链接以及文本。我选择了偏灰的颜色，超链接是紫色系，具体可以自己修改。</p><h3 id="三、Hexo命令"><a href="#三、Hexo命令" class="headerlink" title="三、Hexo命令"></a>三、Hexo命令</h3><p>写作：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">hexo new [layout] &lt;title&gt;<br></code></pre></div></td></tr></table></figure><p>主要有post，page，draft三种，路径都是source。</p><p>也可以自己创建模板。</p><p>常用命令：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">hexo g <span class="hljs-comment">#完整命令为hexo generate,用于生成静态文件</span><br>hexo s <span class="hljs-comment">#完整命令为hexo server,用于启动服务器，主要用来本地预览</span><br>hexo d <span class="hljs-comment">#完整命令为hexo deploy,用于将本地文件发布到github上</span><br>hexo n <span class="hljs-comment">#完整命令为hexo new,用于新建一篇文章</span><br>hexo g -d <span class="hljs-comment">#两个命令的合成，一般在修改或者添加博文后直接使用这个命令</span><br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>教程</category>
      
      <category>博客设置</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>fluid</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>在人间</title>
    <link href="/2020/05/16/%E5%9C%A8%E4%BA%BA%E9%97%B4/"/>
    <url>/2020/05/16/%E5%9C%A8%E4%BA%BA%E9%97%B4/</url>
    
    <content type="html"><![CDATA[<p>离群索居久了，似乎连话也不会说，文章也很少写了。大概有某种投降的意思，放弃了思考和改变，因此也没有什么可以写的内容，甚至连机能也退化了。</p><a id="more"></a><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=1341066656&auto=1&height=66"></iframe><p>对于某些人来说，这当然也不是坏事。所谓人类一思考，上帝就发笑。鼓起勇气去了同学之间的小聚，Z就很看得开，什么波澜壮阔，按部就班一点一点来，于时代来说表现得是一个正常人，也绝无可笑之处。大概大多数人也是如此，像是攀缘的爬山虎，一分一毫，最后总得要到高处去。又或者是北来的归燕，早已在廊檐下凭借着自己，筑了精致的巢穴，也无风雨也无晴。日常呼朋引伴，胡吃海塞，天南地北流窜，谓之情谊。所纠结所烦难，无非是目力所及，心之所向。今日事不能毕，昨日情难以了。这些人，于家于国，都算是中流砥柱，并不会自怨自艾，不会说什么，现实的引力太沉重了这样的屁话，也无甚必要。对我来说，算是某种参照系。</p><p>我读初中的时候，很喜欢看高尔基的三部曲。第一二部讲少年的故事，我的少年生活倒不算如意，所以时时感触，特别觉得书里面的外祖父像极了我的爷爷。等我脱离了这层桎梏，便开始羡慕起青年高尔基来。所有完整的情节现在是记不清了，只记得他最开始去给画圣像的当学徒，和作坊的许多工友混在一起，认识了很多粗鲁且善良的劳动人民，后来又去船上，周游到了里海去。那时我就想，我也想去认识这许多人，去这许多地方。高中的时候翻看《从文自传》，沈从文当着兵，在军队里面流转，并不像在学校里面的孩子们，早早就见识了冷酷仙境，美艳的老板娘，土匪的爱情故事，下到兵痞，上到将军。固然是沈从文诗化了湘西，但是这并不妨碍我的向往。</p><p>这里关乎一个很要紧的问题，什么是人间。人的认知空间到底还是狭小。日常的生活经验，并不足以使我们认识到，人间到底是什么样子。看关口知宏的《中国铁道大纪行》，发现零几年的铁路上，人们像动物一样，早早就开始了季节性的长途奔徙。做着各种各样的生计，并不因此沮丧，对待日本来的客人，也一样真诚善良。这些我都无知无识。北京南站，每一天都会涌来和散去很多的人们，我有心观察过，拎着蛇皮袋的，拖家带口的，大腹便便穿polo衫拎公文包的，衣冠楚楚胸前也挂吊牌的。火车上，听见过有去北京探亲的，看过有两个秃头大爷在火车上喝白酒，还有在连接处不停电话谈业务的。这些人，我绝不知道他们的故事。恍恍惚惚闲云逸鹤，人间红尘过。</p><p>以上大概是某种朴素的价值判断和审美倾向，是我对于现实的某种把握。但是，请不要误会，也许我很久以前想过，但是现在我绝不想做一个吟游诗人。四处游历，和人交谈，固然美妙，如果能以此为生，那便是很多人梦寐以求的了。然而浮于表面的始终浮于表面，这是我个人有所改观的地方。从前的我会觉得，认知的广度和深度足够用来处理现实的问题，现在我大概能够明白，现实生活的经验仍旧是第一位的。物理上对于真理的探查，实际上是用干涉的手段完成的。纯粹的观察者，仅仅意味着，观察的对象于自身无关紧要罢了。这也是我依旧喜欢高尔基和沈从文的原因——他们本人和所看见的人间，是相互塑造的。于是，这些也改变了他们的命运，前者没有在圣像作坊里埋头到老，后者也没有成一个老兵油子在战场上送命，这才使得我们能够窥见他们青年世界的一瞥。</p><p>是在人间，而不是人间。</p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>蒲草集</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>新年随笔二零一九</title>
    <link href="/2019/01/10/%E6%96%B0%E5%B9%B4%E9%9A%8F%E7%AC%94%E4%BA%8C%E9%9B%B6%E4%B8%80%E4%B9%9D/"/>
    <url>/2019/01/10/%E6%96%B0%E5%B9%B4%E9%9A%8F%E7%AC%94%E4%BA%8C%E9%9B%B6%E4%B8%80%E4%B9%9D/</url>
    
    <content type="html"><![CDATA[<p>往往有一种错觉，旧历年还没有过去，新历年已经来临的这段日子，仿佛每一天都是节日。好像是汽车的轮子也打着漂，即使是特别沉稳的人，也会在心里面默默盘算，要去哪里玩，什么样的衣服鞋子，什么样的大菜，乳猪哼哼唧唧趴在大圆桌子上，红透的大虾在盘子里面蹦哒。</p><a id="more"></a><p>倘若是旧时，我还在我们的村子占地为王的时候，我们一行人便会早早起床，趁着阳光没有那么强烈，小水库里面的冰还没有被朝阳触动的时候去砸冰。</p><p>早晨的空气冷冽，软湿的泥土结了冰，踩上去咔嚓咔嚓脆生生弄不脏鞋，路边的又灰又黄枯草也打了霜，白色的冰晶装饰着叶的边缘好像是愈发憔悴，好像是什么八大山人的怪石枯草。已经是冬月，已经是枯水期，黝黑的河床露出来，将水面分成一块一块，水面结的冰打着褶皱，在阳光下面闪闪发光。淤泥也仿佛硬气起来，我们蹑手蹑脚踩上去，挪到水边上，用红色的砂岩小石头去砸碎这面鱼虾的玻璃窗。透明的冰面被砸出洞来，被砸出裂缝，空气透进去，在冰下形成白色的气泡，叫人又有去砸碎的欲望。石子在冰面上滑行发出刺啦刺啦的啸声，我们比着谁的石头扔的远，河床上的石子瓦片扔完，就用碎冰。一厘米左右的冰片在冰面上喀拉碎成小块，每一片在又如水晶一般闪着光辉。喀拉喀拉喀拉，近处的冰也被我们扔完，冰面上一片狼藉，但是我们还不肯罢休。有带擦炮的，点燃一根，专门扔到冰窟窿里面去，等上三五秒，在水底闷地一声，乳白色的气泡冒上来，又被锁在冰面下，形成一个个奇形怪状的乳白色的空腔，久久也不能散去。</p><p>等到太阳又高一点，有妇人出来洗衣服，渔人穿上半身的塑胶衣服下水捞鱼，冰面被我们蹂躏得差不多，河床上的淤泥差不多也开始软趴趴的时候，我们便飞也似的逃窜，顺便捡上一两片蚌壳，等着明天再来这里逞威风……</p><p>这些差不多已经是十年前的光景，许多个日子团成一团，开始怀念的时候，也正如杜拉斯所说，记忆中只有广阔的场景，此处到彼处，光暗如何，冷暖几分，音容笑貌抽象成几个形容词，仿佛再也没有正眼瞧过他们的被冷风吹的红通通的脸，对话也都失去色彩。像是别处再起的楼阁，虚构出形制，草拟出蓝图，再把过去的自己安放其间。</p><p>沉湎于过去当然是极极愚蠢的行为，更何况这些旧人早已作鸟兽散，也听说过各种变故，有过得凄凄惨惨戚戚，有的业已成家，分道扬镳的时间比印象中的要早得多，结局当然也坏得多。之所以谈起这些，无非是时间的滤镜居然抹平了那些残破的记忆，在这流落的时候熠熠生辉起来。然后违心地去想，倘若再来一回，一定要记得所有人的样子，即刻就在心里编下这种种故事，记在日记里，省得这些事情萦绕起来，好像是某种温情，叫人失神。</p><p>辞旧迎新的时节，再谈这些总也不合时宜，总得也作些总结汇报，新年展望，把自己拾掇得像一个人，假模假样地胸前口袋夹着笔，拿着一张表，来来回回边踱步边打个分数。但也正因为难以下笔，所以才想到过去的平凡岁月，那些阳光灿烂的日子，何以逐渐模糊，被时间一一剪切归档，收藏在某个小小角落，然后又将这些素材拿出来，重新拼接剪辑，变成温情故事。然而往者终究不可谏，好像是我爱我家，梁左也已经去世了，京城中流传的早已经不是大院子弟的故事，甚至青春朋克都已经成为历史，命运的转轮不停地旋转，已经2019年了。</p><p>过去的一年，我撞过了每一堵我可能要撞的高墙，摔落了每一道我可能要落进的沟壑，口袋里的扑克牌一一散落，我的朋友在前面驻扎，而我也并不觉得风阻会减小一些。2019，无非也还是一日一日的日常，一日一日，我们假装严肃生活，只等时间裁剪片段，打磨上色，算是为未来保留温情。</p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>新年</tag>
      
      <tag>2019</tag>
      
    </tags>
    
  </entry>
  
  
  
  
  
  
  <entry>
    <title>about</title>
    <link href="/"/>
    <url>/</url>
    
    <content type="html"><![CDATA[<ul><li>物理肄业，爱好者。</li><li>文艺自行车，曾经可以双手脱把。</li><li>盯鞋音乐，China Indie。</li></ul>]]></content>
    
  </entry>
  
  
  
</search>
