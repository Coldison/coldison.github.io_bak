<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Redis的使用入门</title>
    <link href="/2022/10/01/Redis%E7%9A%84%E4%BD%BF%E7%94%A8%E5%85%A5%E9%97%A8/"/>
    <url>/2022/10/01/Redis%E7%9A%84%E4%BD%BF%E7%94%A8%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<p><a href="https://e-learning.51cto.com/course/12370">Redis入门及python操作视频课程</a><br><a href="https://redis.io/docs/about/">Redis Documents</a></p><p>Redis是一个开源的内存数据存储服务，可以用作实时数据存储，缓存与session存取，流数据与消息存取。</p><h2 id="Redis安装、配置与运行"><a href="#Redis安装、配置与运行" class="headerlink" title="Redis安装、配置与运行"></a>Redis安装、配置与运行</h2><h3 id="Redis安装"><a href="#Redis安装" class="headerlink" title="Redis安装"></a>Redis安装</h3><p><a href="https://redis.io/docs/getting-started/installation/install-redis-from-source/">Redis官方文档：安装Redis</a><br>官网提供了在不同系统安装Redis的方式，这里是从源代码安装。</p><h4 id="从源代码安装"><a href="#从源代码安装" class="headerlink" title="从源代码安装"></a>从源代码安装</h4><p>我参考的是<a href="https://blog.csdn.net/a_rain2333/article/details/119567362">CentOS7redis安装教程</a>。</p><p>处于权限的考虑，最好切换到root用户，如果不是的话应该也没关系，redis-server的进程因此就属于用户。</p><p>安装gcc</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">yum install -y gcc <br></code></pre></td></tr></table></figure><p>下载并解压redis</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">wget https://download.redis.io/releases/redis-6.2.5.tar.gz<br>tar -zvxf redis-6.2.5.tar.gz<br></code></pre></td></tr></table></figure><p>移动文件夹，不移动到该文件夹也没问题，只要记得自己的文件目录就可以。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">mv redis-6.2.5 /usr/<span class="hljs-built_in">local</span>/redis<br></code></pre></td></tr></table></figure><p>cd到redis目录，键入<code>make</code>命令进行编译。编译完成最好<code>make test</code>一下，如果没有报错就没问题。然后</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">make PREFIX=/usr/<span class="hljs-built_in">local</span>/redis install<br></code></pre></td></tr></table></figure><h4 id="基于Docker"><a href="#基于Docker" class="headerlink" title="基于Docker"></a>基于Docker</h4><p>参考菜鸟教程<a href="https://www.runoob.com/docker/docker-install-redis.html">docker安装redis</a>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker pull redis:latest<br></code></pre></td></tr></table></figure><p>按照默认配置运行，docker的run命令可以参考我的<a href="https://coldison.github.io/2022/09/15/Docker%E7%9A%84%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B(%E4%B8%80)/">Docker的使用示例(一)</a>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run -itd --name redis-test -p 6379:6379 redis<br></code></pre></td></tr></table></figure><p>容器中运行bash</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker <span class="hljs-built_in">exec</span> -it redis-test /bin/bash<br></code></pre></td></tr></table></figure><p>容器中运行redis-cli:<br><img src="https://www.runoob.com/wp-content/uploads/2016/06/docker-redis7.png" alt="容器中运行redis-cli"></p><h3 id="redis的配置与运行"><a href="#redis的配置与运行" class="headerlink" title="redis的配置与运行"></a>redis的配置与运行</h3><h4 id="redis的配置"><a href="#redis的配置" class="headerlink" title="redis的配置"></a>redis的配置</h4><p>redis文件夹中有redis.conf文件。</p><p>我用到的有两个：</p><ol><li><code>bind 127.0.0.1</code>：绑定的主机地址。</li><li><code>port 6379</code>： 指定Redis监听端口，默认端口为6379。</li></ol><p>补充部分可以暂时不看：</p><ol><li><p><code>daemonize yes</code>：Redis默认以守护进程运行，设置no关闭。</p></li><li><p><code>pidfile /var/run/redis.pid</code>：当Redis以守护进程方式运行时，Redis默认会把pid写入<code>/var/run/redis.pid</code>文件，可以通过pidfile指定。</p></li><li><p><code>timeout 300</code>：当客户端闲置多长时间后关闭连接，如果指定为0，表示关闭该功能。</p></li><li><p><code>loglevel verbose</code>：指定日志记录级别，Redis总共支持四个级别：debug、verbose、notice、warning，默认为verbose。</p></li><li><p><code>logfile stdout</code>：日志记录方式，默认为标准输出，如果配置Redis为守护进程方式运行，而这里又配置为日志记录方式为标准输出，则日志将会发送给<code>/dev/null</code>。</p></li><li><p><code>database 16</code>：设置数据库的数量，默认数据库id为0，可以使用<code>SELECT &lt;dbid&gt;</code>命令在连接上指定数据库id。</p></li><li><p><code>save &lt;seconds&gt; &lt;changes&gt;</code>：指定在多长时间内，有多少次更新操作，就将数据同步到数据文件，可以多个条件配合。默认配置文件：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs conf">save 900 1<br>save 300 10<br>save 60 10000<br></code></pre></td></tr></table></figure><p>分别表示900秒（15分钟）内有1个更改，300秒（5分钟）内有10个更改以及60秒内有10000个更改。</p></li><li><p><code>rdbcompression yes</code>：指定存储至本地数据库时是否压缩数据，默认为yes，Redis采用LZF压缩，如果为了节省CPU时间，可以关闭该选项，但会导致数据库文件变的巨大。</p></li><li><p><code>dbfilename dump.rdb</code>：指定本地数据库文件名，默认值为dump.rdb。</p></li><li><p><code>dir ./</code>：指定本地数据库文件名，默认值为dump.rdb。</p></li><li><p><code>slaveof &lt;masterip&gt; &lt;masterport&gt;</code>：设置当本机为slave服务时，设置master服务的IP地址及端口，在Redis启动时，它会自动从master进行数据同步。</p></li><li><p><code>masterauth &lt;master-password&gt;</code>： 当master服务设置了密码保护时，slave服务连接master的密码。</p></li><li><p><code>requirepass foobared</code>：设置Redis连接密码，如果配置了连接密码，客户端在连接Redis时需要通过<code>AUTH &lt;password&gt;</code>命令提供密码，默认关闭。</p></li><li><p><code>maxclients 128</code>：设置同一时间最大客户端连接数，默认无限制，Redis可以同时打开的客户端连接数为Redis进程可以打开的最大文件描述符数，如果设置 maxclients 0，表示不作限制。当客户端连接数到达限制时，Redis会关闭新的连接并向客户端返回<code>max number of clients reached</code>错误信息。</p></li></ol><h4 id="redis的运行"><a href="#redis的运行" class="headerlink" title="redis的运行"></a>redis的运行</h4><p>运行服务端：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">./bin/redis-server redis.conf<br></code></pre></td></tr></table></figure><p>如果不指定conf文件，则redis会按照默认的conf运行，当然也有可能找不到defaultconf。</p><p>运行自带的redis客户端<code>./redis-cli</code>，可以加上<code>-p</code>指定端口，因为默认是6379而我这里被默认的Ray的redis给占用了，所以指定端口为6879。然后就可以输入Redis命令，接下来就是操作Redis基本数据类型的命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">(base) [coldison@localhost bin]$ ./redis-cli<br>127.0.0.1:6379&gt; <span class="hljs-built_in">set</span> funnything standupcomedy<br>Error: Protocol error, got <span class="hljs-string">&quot;\x00&quot;</span> as reply <span class="hljs-built_in">type</span> byte<br>(base) [coldison@localhost bin]$ ./redis-cli -p 6879<br>127.0.0.1:6879&gt; <span class="hljs-built_in">set</span> funnything standupcomedy<br>OK<br>127.0.0.1:6879&gt; <br></code></pre></td></tr></table></figure><h2 id="Redis的数据类型"><a href="#Redis的数据类型" class="headerlink" title="Redis的数据类型"></a>Redis的数据类型</h2><p><a href="https://redis.io/docs/data-types/">redis官方文档: 数据类型</a><br>redis的数据类型有：<a href="#string-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B">string</a>，<a href="#list-%E5%88%97%E8%A1%A8%E7%B1%BB%E5%9E%8B">list</a>，<a href="#set-%E9%9B%86%E5%90%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">set</a>，<a href="#hash-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">hash</a>，类似于python的dict。还有<a href="https://redis.io/docs/data-types/sorted-sets/">有序集合sorted sets</a>，<a href="https://redis.io/docs/data-types/streams">stream</a>(主要用于日志)，<a href="https://redis.io/docs/data-types/geospatial/">Geospatial indexes</a>，<a href="https://redis.io/docs/data-types/bitmaps/">Bitmaps</a>，<a href="https://redis.io/docs/data-types/bitfields/">Bitfields</a>，<a href="https://redis.io/docs/data-types/hyperloglogs">HyperLogLog</a>(为大规模集合提供元素的概率预测)。数据结构可以基于Redis Stack自行扩展。</p><h3 id="string-字符串类型"><a href="#string-字符串类型" class="headerlink" title="string 字符串类型"></a>string 字符串类型</h3><ul><li>stringg是redis最基本的类型，而且string类型是二进制安全的。</li><li>redis的string可以包含任何数据。包括jpg图片或者序列化的对象。</li><li>最大上限是1G字节。</li><li>如果只用string类型，redis就可以被看作加上持久化特性的memcached</li></ul><p>例如在集群的进程管理中，ssession通常是以string的形式存取的。</p><ol><li><p><code>set key value</code>：设置key对应的值为string类型的value,返回1表示成功，0失败。</p></li><li><p><code>setnx key value</code>：同上，如果key已经存在，返回0，表明设置失败。nx是not exist的意思。</p></li><li><p><code>get key</code>：获取key对应的string值,如果key不存在返回nil。</p></li><li><p><code>getset key value</code>：设置key的值，并返回key的旧值。如果key不存在返回nil，同时设置成功。</p></li><li><p><code>mget key1 key2 ... keyN</code>： 一次获取多个key的值，如果对应key不存在，则对应返 回nil。下面是个实验, nonexisting不存在，对应返回nil。</p></li><li><p><code>mset key1 value1 ... keyN valueN</code>： 一次设置多个key的值，成功返回1表示所有的值都设置了，失败返回0表示没有任何值被设置。</p></li><li><p><code>msetnx key1 value1 ... keyN valueN</code>： 同上，但是不会覆盖已经存在的key，返回0代表设置失败。</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6879&gt; mset f1 t1 f2 t2 f3 sorry<br>OK<br>127.0.0.1:6879&gt; mget f2 f3<br>1) <span class="hljs-string">&quot;t2&quot;</span><br>2) <span class="hljs-string">&quot;sorry&quot;</span><br>127.0.0.1:6879&gt; mget f2 f3 f4<br>1) <span class="hljs-string">&quot;t2&quot;</span><br>2) <span class="hljs-string">&quot;sorry&quot;</span><br>3) (nil)<br>127.0.0.1:6879&gt; mset f1 t1 f2 t2 f3 toobad<br>OK<br>127.0.0.1:6879&gt; msetnx f1 t1 f2 t2 f3 toobad<br>(<span class="hljs-built_in">integer</span>) 0<br></code></pre></td></tr></table></figure></li><li><p><code>incr key</code>： 对key的值做加加操作,并返回新的值。注意incr一个不是int的value会返回错误，incr一个不存在的key，则设置key为1。</p></li><li><p><code>decr key</code>：同上，但是做的是减减操作，decr一个不存在key，则设置key为-1。</p></li><li><p><code>incrby key integer</code>：同incr，加指定值，key不存在时候会设置key，并认为原来的value是0。</p></li><li><p><code>decrby key integer</code>：同decr，减指定值。decrby完全是为了可读性，我们<br>完全可以通过incrby一个负值来实现同样效果，反之一样。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6879&gt; mset n1 1 n2 2<br>OK<br>127.0.0.1:6879&gt; incr n1 n2<br>(error) ERR wrong number of arguments <span class="hljs-keyword">for</span> <span class="hljs-string">&#x27;incr&#x27;</span> <span class="hljs-built_in">command</span><br>127.0.0.1:6879&gt; incr n1<br>(<span class="hljs-built_in">integer</span>) 2<br>127.0.0.1:6879&gt; incr n3<br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6879&gt; incr f1<br>(error) ERR value is not an <span class="hljs-built_in">integer</span> or out of range<br>127.0.0.1:6879&gt; decr n1<br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6879&gt; incrby n3 100<br>(<span class="hljs-built_in">integer</span>) 101<br>127.0.0.1:6879&gt; decrby n3 23<br>(<span class="hljs-built_in">integer</span>) 78<br>127.0.0.1:6879&gt; incrby n5 9<br>(<span class="hljs-built_in">integer</span>) 9<br>127.0.0.1:6879&gt; decrby n6 12<br>(<span class="hljs-built_in">integer</span>) -12<br></code></pre></td></tr></table></figure></li><li><p><code>append key value</code>：给指定key的字符串值追加value,返回新字符串值的长度。数字也可以被当作字符串看待。</p></li><li><p><code>substr key start end</code>：返回截取过的key的字符串值,注意并不修改key的值。下标是从0开始的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6879&gt; get funnything<br><span class="hljs-string">&quot;standupcomedy&quot;</span><br>127.0.0.1:6879&gt; append funnything abroad<br>(<span class="hljs-built_in">integer</span>) 19<br>127.0.0.1:6879&gt; get funnything<br><span class="hljs-string">&quot;standupcomedyabroad&quot;</span><br>127.0.0.1:6879&gt; substr funnything 3 12<br><span class="hljs-string">&quot;ndupcomedy&quot;</span><br>127.0.0.1:6879&gt; get n3<br><span class="hljs-string">&quot;78&quot;</span><br>127.0.0.1:6879&gt; append n3 warriors<br>(<span class="hljs-built_in">integer</span>) 10<br>127.0.0.1:6879&gt; get n3<br><span class="hljs-string">&quot;78warriors&quot;</span><br>127.0.0.1:6879&gt; incr n3 <br>(error) ERR value is not an <span class="hljs-built_in">integer</span> or out of range<br></code></pre></td></tr></table></figure><h3 id="list-列表类型"><a href="#list-列表类型" class="headerlink" title="list 列表类型"></a>list 列表类型</h3></li></ol><p>redis的list类型其实就是一个每个子元素都是string类型的双向链表。我们可以<br>通过push,pop操作从链表的头部或者尾部添加删除元素。这使得list既可以用<br>作栈，也可以用作队列。<br>list的pop操作还有阻塞版本的。当我们[lr]pop一个list对象是，如果list是空，<br>或者不存在，会立即返回nil。但是阻塞版本的b[lr]pop可以则可以阻塞，当然<br>可以加超时时间，超时后也会返回nil。为什么要阻塞版本的pop呢，主要是为<br>了避免轮询。举个简单的例子如果我们用list来实现一个工作队列。执行任务<br>的thread可以调用阻塞版本的pop去获取任务这样就可以避免轮询去检查是<br>否有任务存在。当任务来时候工作线程可以立即返回，也可以避免轮询带来的<br>延迟。</p><ol><li><p><code>lpush key string</code>：在key对应list的头部添加字符串元素，<strong>不存在key则创建</strong>，空格为元素定界符，返回1表示成功，0表示key存在且不是list类型。</p></li><li><p><code>rpush key string</code>：同上，在尾部添加。</p></li><li><p><code>llen key</code>：返回key对应list的长度，key不存在返回0,如果key对应类型不是list返回错误。</p></li><li><p><code>lrange key start end</code>：返回指定区间内的元素，下标从0开始，负值表示从后 面计算，-1表示倒数第一个元素 ，key不存在返回空列表。</p></li><li><p><code>ltrim key start end</code>：截取list，保留指定区间内元素，成功返回1，key不存在返回错误。</p></li><li><p><code>lset key index value</code>：设置list中指定下标的元素值，成功返回1，key或者下标不存在返回错误。</p></li><li><p><code>lrem key count value</code>：从key对应list中删除count个和value相同的元素。 count为0时候删除全部。</p></li><li><p><code>lpop key</code>：从list的头部删除元素，并返回删除元素。如果key对应list不存在或者是空返回nil，如果key对应值不是list返回错误。</p></li><li><p><code>rpop key</code>：同上，但是从尾部删除。</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6879&gt; lpush list1 a b c <br>(<span class="hljs-built_in">integer</span>) 3<br>127.0.0.1:6879&gt; rpush list2 x y z<br>(<span class="hljs-built_in">integer</span>) 3<br>127.0.0.1:6879&gt; llen list1<br>(<span class="hljs-built_in">integer</span>) 3<br>127.0.0.1:6879&gt; lrange list2 0 -1<br>1) <span class="hljs-string">&quot;x&quot;</span><br>2) <span class="hljs-string">&quot;y&quot;</span><br>3) <span class="hljs-string">&quot;z&quot;</span><br>127.0.0.1:6879&gt; rrange list2 0 -1<br>(error) ERR unknown <span class="hljs-built_in">command</span> `rrange`, with args beginning with: `list2`, `0`, `-1`, <br>127.0.0.1:6879&gt; lpush list3 alpha beta gamma theta<br>(<span class="hljs-built_in">integer</span>) 4<br>127.0.0.1:6879&gt; ltrim list3 2 4<br>OK<br>127.0.0.1:6879&gt; lrange list3 0 -1<br>1) <span class="hljs-string">&quot;beta&quot;</span><br>2) <span class="hljs-string">&quot;alpha&quot;</span><br></code></pre></td></tr></table></figure></li><li><p><code>blpop key1...keyN timeout</code>：从左到右扫描返回对第一个非空list进行lpop操作并返回，比如<code>blpop list1 list2 list3 0</code>,如果<code>list1</code>不存在，<code>list2,list3</code>都是非空则对list2做lpop并返回从list2中删除的元素。如果所有的list都是空或不存在，则会阻塞timeout秒，timeout为0表示一直阻塞。当阻塞时，如果有client对key1…keyN中的任意key进行push操作，则第一在这个key上被阻塞的client会立即返回。如果超时发生，则返回nil。<em>返回两个值，一个是key，一个是value。</em></p></li><li><p><code>brpop</code>：同blpop，一个是从头部删除一个是从尾部删除。</p></li><li><p><code>rpoplpush srckey destkey</code>：从srckey对应list的尾部移除元素并添加到 destkey对应list的头部,最后返回被移除的元素值，整个操作是原子的。如果srckey是空或者不存在返回nil。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6879&gt; blpop list1 list2 list3 0<br>1) <span class="hljs-string">&quot;list1&quot;</span><br>2) <span class="hljs-string">&quot;c&quot;</span><br>127.0.0.1:6879&gt; lrange list1 0 -1<br>1) <span class="hljs-string">&quot;b&quot;</span><br>2) <span class="hljs-string">&quot;a&quot;</span><br>127.0.0.1:6879&gt; lrange list2 0 -1<br>1) <span class="hljs-string">&quot;x&quot;</span><br>2) <span class="hljs-string">&quot;y&quot;</span><br>3) <span class="hljs-string">&quot;z&quot;</span><br>127.0.0.1:6879&gt; blpop li1 li2 li3 li4 0<br>1) <span class="hljs-string">&quot;li2&quot;</span><br>2) <span class="hljs-string">&quot;chen&quot;</span><br>(331.66s)<br>127.0.0.1:6879&gt; rpoplpush list2 list3<br><span class="hljs-string">&quot;z&quot;</span><br></code></pre></td></tr></table></figure><h3 id="set-集合数据类型"><a href="#set-集合数据类型" class="headerlink" title="set 集合数据类型"></a>set 集合数据类型</h3></li></ol><ul><li>redis的set是string类型的无序集合。</li><li>set元素最大可以包含(2的32次方-1)个元素。</li><li>set的是通过hash table实现的，hash table会随着添加或者删除自动的调整<br>大小。</li><li>关于set集合类型除了基本的添加删除操作，其他有用的操作还包含集合的取<br>并集(union)，交集(intersection)，差集(difference)。通过这些操作可以很<br>容易的实现sns中的好友推荐和blog的tag功能。</li></ul><ol><li><p><code>sadd key member</code>：添加一个string元素到,key对应的set集合中，成功返回1,如果元素以及在集合中返回0，key对应的set不存在返回错误。</p></li><li><p><code>srem key member</code>：从key对应set中移除给定元素，成功返回1，如果member在<br>集合中不存在或者key不存在返回0，如果key对应的不是set类型的值返回错误。如果既有存在的也有不存在的元素，则返回删去元素的数量。</p></li><li><p><code>spop key</code>：删除并返回key对应set中随机的一个元素,如果set是空或者key不存在返回nil。</p></li><li><p><code>srandmember key</code>：同spop，随机取set中的一个元素，但是不删除元素。</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6879&gt; sadd set1 butter<br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6879&gt; sadd list1 beer<br>(error) WRONGTYPE Operation against a key holding the wrong kind of value<br>127.0.0.1:6879&gt; sadd set1 beer<br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6879&gt; sadd set1 cup<br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6879&gt; sadd set1 cake muffin doughnut<br>(<span class="hljs-built_in">integer</span>) 3<br>127.0.0.1:6879&gt; srem <span class="hljs-built_in">set</span> muffin cake<br>(<span class="hljs-built_in">integer</span>) 0<br>127.0.0.1:6879&gt; srem set1 muffin cake <span class="hljs-built_in">cap</span><br>(<span class="hljs-built_in">integer</span>) 2<br>127.0.0.1:6879&gt; smembers set1<br>1) <span class="hljs-string">&quot;doughnut&quot;</span><br>2) <span class="hljs-string">&quot;cup&quot;</span><br>3) <span class="hljs-string">&quot;beer&quot;</span><br>4) <span class="hljs-string">&quot;butter&quot;</span><br>127.0.0.1:6879&gt; spop set1<br><span class="hljs-string">&quot;doughnut&quot;</span><br>127.0.0.1:6879&gt; srandmember set1<br><span class="hljs-string">&quot;butter&quot;</span><br></code></pre></td></tr></table></figure></li><li><p><code>smove srckey dstkey member</code>：从srckey对应set中移除member并添加到<br>dstkey对应set中，整个操作是原子的，意思是只能操作单个元素。成功返回1,如果member在srckey中不存在返回0，如果key不是set类型返回错误。</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6879&gt; sadd set2 muffin doughnut sandwich croissant hotdog cheesecake<br>(<span class="hljs-built_in">integer</span>) 6<br>127.0.0.1:6879&gt; smembers set1<br>1) <span class="hljs-string">&quot;cup&quot;</span><br>2) <span class="hljs-string">&quot;beer&quot;</span><br>3) <span class="hljs-string">&quot;butter&quot;</span><br>127.0.0.1:6879&gt; smembers set2<br>1) <span class="hljs-string">&quot;croissant&quot;</span><br>2) <span class="hljs-string">&quot;sandwich&quot;</span><br>3) <span class="hljs-string">&quot;muffin&quot;</span><br>4) <span class="hljs-string">&quot;doughnut&quot;</span><br>5) <span class="hljs-string">&quot;cheesecake&quot;</span><br>6) <span class="hljs-string">&quot;hotdog&quot;</span><br>127.0.0.1:6879&gt; smove set2 set1 muffin<br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6879&gt; smove set2 set1 muffin cake<br>(error) ERR wrong number of arguments <span class="hljs-keyword">for</span> <span class="hljs-string">&#x27;smove&#x27;</span> <span class="hljs-built_in">command</span><br>127.0.0.1:6879&gt; smove set2 set1 muffin <br>(<span class="hljs-built_in">integer</span>) 0<br></code></pre></td></tr></table></figure></li><li><p><code>scard key</code>：返回set的元素个数，如果set是空或者key不存在返回0。</p></li><li><p><code>sismember key member</code>：判断member是否在set中，存在返回1，0表示不存在<br>或者key不存在。</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6879&gt; scard set2<br>(<span class="hljs-built_in">integer</span>) 5<br>127.0.0.1:6879&gt; sismember set2 taco<br>(<span class="hljs-built_in">integer</span>) 0<br>127.0.0.1:6879&gt; sismember set2 cheesecake<br>(<span class="hljs-built_in">integer</span>) 1<br></code></pre></td></tr></table></figure></li><li><p><code>sinter key1 key2...keyN</code>：返回所有给定key的交集。</p></li><li><p><code>sinterstore dstkey key1...keyN</code>：同sinter，但是会同时将交集存到dstkey下，覆盖原来的集合。</p></li><li><p><code>sunion key1 key2...keyN</code>：返回所有给定key的并集。</p></li><li><p><code>sunionstore dstkey key1...keyN</code>： 同sunion，并同时保存并集到dstkey下，覆盖原来的集合。</p></li><li><p><code>sdiff key1 key2...keyN</code>：返回所有给定key的差集。</p></li><li><p><code>sdiffstore dstkey key1...keyN</code>：同sdiff，并同时保存差集到dstkey下。</p></li><li><p><code>smembers key</code>：返回key对应set的所有元素，结果是无序的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6879&gt; smembers set1<br>1) <span class="hljs-string">&quot;burrito&quot;</span><br>2) <span class="hljs-string">&quot;cup&quot;</span><br>3) <span class="hljs-string">&quot;taco&quot;</span><br>4) <span class="hljs-string">&quot;beer&quot;</span><br>5) <span class="hljs-string">&quot;butter&quot;</span><br>6) <span class="hljs-string">&quot;hotdog&quot;</span><br>7) <span class="hljs-string">&quot;sandwich&quot;</span><br>8) <span class="hljs-string">&quot;muffin&quot;</span><br>127.0.0.1:6879&gt; smembers set2<br>1) <span class="hljs-string">&quot;doughnut&quot;</span><br>2) <span class="hljs-string">&quot;croissant&quot;</span><br>3) <span class="hljs-string">&quot;cheesecake&quot;</span><br>4) <span class="hljs-string">&quot;sandwich&quot;</span><br>5) <span class="hljs-string">&quot;hotdog&quot;</span><br>127.0.0.1:6879&gt; smembers set3<br>1) <span class="hljs-string">&quot;avacado&quot;</span><br>2) <span class="hljs-string">&quot;pickle&quot;</span><br>127.0.0.1:6879&gt; sinter set1 set2 set3<br>(empty array)<br>127.0.0.1:6879&gt; sinter set1 set2 <br>1) <span class="hljs-string">&quot;sandwich&quot;</span><br>2) <span class="hljs-string">&quot;hotdog&quot;</span><br>127.0.0.1:6879&gt; sinterstore set4 set1 set2 <br>(<span class="hljs-built_in">integer</span>) 2<br>127.0.0.1:6879&gt; smembers set4<br>1) <span class="hljs-string">&quot;hotdog&quot;</span><br>2) <span class="hljs-string">&quot;sandwich&quot;</span><br>127.0.0.1:6879&gt; sunion set1 set2 set3<br>1) <span class="hljs-string">&quot;burrito&quot;</span><br>2) <span class="hljs-string">&quot;doughnut&quot;</span><br>3) <span class="hljs-string">&quot;beer&quot;</span><br>4) <span class="hljs-string">&quot;butter&quot;</span><br>5) <span class="hljs-string">&quot;cheesecake&quot;</span><br>6) <span class="hljs-string">&quot;sandwich&quot;</span><br>7) <span class="hljs-string">&quot;pickle&quot;</span><br>8) <span class="hljs-string">&quot;avacado&quot;</span><br>9) <span class="hljs-string">&quot;cup&quot;</span><br>10) <span class="hljs-string">&quot;taco&quot;</span><br>11) <span class="hljs-string">&quot;croissant&quot;</span><br>12) <span class="hljs-string">&quot;hotdog&quot;</span><br>13) <span class="hljs-string">&quot;muffin&quot;</span><br>127.0.0.1:6879&gt; sunionstore set4 set1 set2 set3<br>(<span class="hljs-built_in">integer</span>) 13<br>127.0.0.1:6879&gt; smembers set4<br>1) <span class="hljs-string">&quot;burrito&quot;</span><br>2) <span class="hljs-string">&quot;doughnut&quot;</span><br>3) <span class="hljs-string">&quot;beer&quot;</span><br>4) <span class="hljs-string">&quot;butter&quot;</span><br>5) <span class="hljs-string">&quot;cheesecake&quot;</span><br>6) <span class="hljs-string">&quot;sandwich&quot;</span><br>7) <span class="hljs-string">&quot;pickle&quot;</span><br>8) <span class="hljs-string">&quot;avacado&quot;</span><br>9) <span class="hljs-string">&quot;cup&quot;</span><br>10) <span class="hljs-string">&quot;taco&quot;</span><br>11) <span class="hljs-string">&quot;croissant&quot;</span><br>12) <span class="hljs-string">&quot;hotdog&quot;</span><br>13) <span class="hljs-string">&quot;muffin&quot;</span><br>127.0.0.1:6879&gt; sadd set5 skittle kitkat<br>(<span class="hljs-built_in">integer</span>) 2<br>127.0.0.1:6879&gt; sunionstore set5 set1 set2 set3<br>(<span class="hljs-built_in">integer</span>) 13<br>127.0.0.1:6879&gt; smembers set5<br>1) <span class="hljs-string">&quot;burrito&quot;</span><br>2) <span class="hljs-string">&quot;doughnut&quot;</span><br>3) <span class="hljs-string">&quot;beer&quot;</span><br>4) <span class="hljs-string">&quot;butter&quot;</span><br>5) <span class="hljs-string">&quot;cheesecake&quot;</span><br>6) <span class="hljs-string">&quot;sandwich&quot;</span><br>7) <span class="hljs-string">&quot;pickle&quot;</span><br>8) <span class="hljs-string">&quot;avacado&quot;</span><br>9) <span class="hljs-string">&quot;cup&quot;</span><br>10) <span class="hljs-string">&quot;taco&quot;</span><br>11) <span class="hljs-string">&quot;croissant&quot;</span><br>12) <span class="hljs-string">&quot;hotdog&quot;</span><br>13) <span class="hljs-string">&quot;muffin&quot;</span><br>127.0.0.1:6879&gt; sdiff set2 set1<br>1) <span class="hljs-string">&quot;doughnut&quot;</span><br>2) <span class="hljs-string">&quot;cheesecake&quot;</span><br>3) <span class="hljs-string">&quot;croissant&quot;</span><br>127.0.0.1:6879&gt; sdiff set5 set2 set1<br>1) <span class="hljs-string">&quot;avacado&quot;</span><br>2) <span class="hljs-string">&quot;pickle&quot;</span><br>127.0.0.1:6879&gt; sdiffstore set6 set5 set2 set1<br>(<span class="hljs-built_in">integer</span>) 2<br></code></pre></td></tr></table></figure><h3 id="hash-数据类型"><a href="#hash-数据类型" class="headerlink" title="hash 数据类型"></a>hash 数据类型</h3></li></ol><p>redis hash是一个string类型的field和value的映射表。hash特别适合用于存储对象。相较于将对象的每个字段存成单个string类型。将一个对象存储在hash类型中会占用更少的内存，并且可以更方便的存取整个对象。</p><ol><li><p><code>hset key field value</code>：设置hash field为指定值，如果key不存在，则先创建。</p></li><li><p><code>hget key field</code>：获取指定的hash field。</p></li><li><p><code>hmget key field1....fieldN</code>：获取全部指定的hash filed。</p></li><li><p><code>hmset key field1 value1 ... fieldN valueN</code>：同时设置hash的多个field，成功则返回OK；<code>hset</code>也可以同时设置多个field，返回field数量。</p></li><li><p><code>hincrby key field integer</code>：将指定的<code>hash field</code>加上给定值，前提是field对应的value也同样是integer。</p></li><li><p><code>hexists key field</code>：测试指定field是否存在，存在则返回1。</p></li><li><p><code>hdel key field</code>：删除指定的hash field。</p></li><li><p><code>hlen key</code>：返回指定hash的field数量。</p></li><li><p><code>hkeys key</code>：返回hash的所有field。</p></li><li><p><code>hvals key</code>：返回hash的所有value</p></li><li><p><code>hgetall</code>：返回hash的所有field和value</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6879&gt; hset k1 f1 v1 f2 v2<br>(<span class="hljs-built_in">integer</span>) 2<br>127.0.0.1:6879&gt; hgetall k1<br>1) <span class="hljs-string">&quot;f1&quot;</span><br>2) <span class="hljs-string">&quot;v1&quot;</span><br>3) <span class="hljs-string">&quot;f2&quot;</span><br>4) <span class="hljs-string">&quot;v2&quot;</span><br>127.0.0.1:6879&gt; hset k2 f2 v2 f3 v3<br>(<span class="hljs-built_in">integer</span>) 2<br>127.0.0.1:6879&gt; hget k2 f2<br><span class="hljs-string">&quot;v2&quot;</span><br>127.0.0.1:6879&gt; hmget k2 f2 f3<br>1) <span class="hljs-string">&quot;v2&quot;</span><br>2) <span class="hljs-string">&quot;v3&quot;</span><br>127.0.0.1:6879&gt; hmset k3 f3 v3 f4 v4 f5 v5<br>OK<br>127.0.0.1:6879&gt; hincrby k2 f2 3<br>(error) ERR <span class="hljs-built_in">hash</span> value is not an <span class="hljs-built_in">integer</span><br>127.0.0.1:6879&gt; hset k4 f4 3<br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6879&gt; hincrby k4 f4 5<br>(<span class="hljs-built_in">integer</span>) 8<br>127.0.0.1:6879&gt; hgetall k4<br>1) <span class="hljs-string">&quot;f4&quot;</span><br>2) <span class="hljs-string">&quot;8&quot;</span><br><br>127.0.0.1:6879&gt; hexists k1 f1<br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6879&gt; hexists k1 f3<br>(<span class="hljs-built_in">integer</span>) 0<br><br>127.0.0.1:6879&gt; hexists k1 f1<br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6879&gt; hexists k1 f3<br>(<span class="hljs-built_in">integer</span>) 0<br>127.0.0.1:6879&gt; hdel k3 f3 f4<br>(<span class="hljs-built_in">integer</span>) 2<br>127.0.0.1:6879&gt; hgetall k3<br>1) <span class="hljs-string">&quot;f5&quot;</span><br>2) <span class="hljs-string">&quot;v5&quot;</span><br>127.0.0.1:6879&gt; hlen k2<br>(<span class="hljs-built_in">integer</span>) 2<br>127.0.0.1:6879&gt; hkeys k3<br>1) <span class="hljs-string">&quot;f5&quot;</span><br>127.0.0.1:6879&gt; hvals k4<br>1) <span class="hljs-string">&quot;8&quot;</span><br></code></pre></td></tr></table></figure><h2 id="python操作redis"><a href="#python操作redis" class="headerlink" title="python操作redis"></a>python操作redis</h2></li></ol><h3 id="python安装redis模块"><a href="#python安装redis模块" class="headerlink" title="python安装redis模块"></a>python安装redis模块</h3><p>python 操作redis的相关模块是 redis。<br>安装redis模块：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pip install redis <br></code></pre></td></tr></table></figure><h3 id="python使用redis"><a href="#python使用redis" class="headerlink" title="python使用redis"></a>python使用redis</h3><p>先与redis-server建立连接，由于我们之前设定<code>host=127.0.0.1</code>，端口6879，这里设置一下就可以。同样如果是远程存取也是没问题的。然后实例化<code>redis.Redis()</code>。这里只给出了简单存取string，更多的方法可以参见<code>Redis()</code>源码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> redis <br>pool = redis.ConnectionPool(host=<span class="hljs-string">&#x27;localhost&#x27;</span>, port=<span class="hljs-number">6879</span>, decode_responses=<span class="hljs-literal">True</span>) <br>r = redis.Redis(connection_pool=pool) <br>r.<span class="hljs-built_in">set</span>(<span class="hljs-string">&#x27;food&#x27;</span>,<span class="hljs-string">&#x27;apple&#x27;</span>) <br><span class="hljs-built_in">print</span>(r.get(<span class="hljs-string">&#x27;food&#x27;</span>)) <br>r.hset(<span class="hljs-string">&#x27;foods&#x27;</span>,<span class="hljs-string">&#x27;apple&#x27;</span>,<span class="hljs-string">&#x27;yuande&#x27;</span>) <br><span class="hljs-built_in">print</span>(r.hget(‘foods<span class="hljs-string">&#x27;,&#x27;</span>apple<span class="hljs-string">&#x27;))</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>教程</category>
      
      <category>Redis使用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker的使用示例(一)</title>
    <link href="/2022/09/15/Docker%E7%9A%84%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B(%E4%B8%80)/"/>
    <url>/2022/09/15/Docker%E7%9A%84%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B(%E4%B8%80)/</url>
    
    <content type="html"><![CDATA[<p><a href="https://docs.docker.com/reference/">Docker 官方文档</a></p><p>现在我们可以来实际实践一下docker技术。我这里的需求，在docker容器中运行c，通过host的端口连接指定的IP地址。这是基本的描述，还有如下的细节：</p><ul><li>程序运行时需要在root目录下创建一个conf文件，因此需要先尝试docker的terminal。</li><li>程序作为模拟节点会从一个txt里面读取名称，希望和暴露的端口一起都作为镜像的参数，并且将参数写入相应的文件。</li></ul><h2 id="基础镜像CentOS测试"><a href="#基础镜像CentOS测试" class="headerlink" title="基础镜像CentOS测试"></a>基础镜像CentOS测试</h2><h3 id="将普通用户加入docker用户组"><a href="#将普通用户加入docker用户组" class="headerlink" title="将普通用户加入docker用户组"></a>将普通用户加入docker用户组</h3><p>普通用户需要加入docker用户组才能够使用docker。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 切换成root用户</span><br>su - <br>sudo groupadd docker     <span class="hljs-comment">#添加docker用户组</span><br>sudo gpasswd -a <span class="hljs-variable">$USER</span> docker     <span class="hljs-comment">#将登陆用户加入到docker用户组中</span><br>newgrp docker     <span class="hljs-comment">#更新用户组</span><br>docker ps    <span class="hljs-comment">#测试docker命令是否可以使用sudo正常使用</span><br></code></pre></td></tr></table></figure><h3 id="dockerbuild镜像"><a href="#dockerbuild镜像" class="headerlink" title="dockerbuild镜像"></a>dockerbuild镜像</h3><p>由于docker是一层一层叠加，我们可以先从简单的开始，得到的镜像层可以复用。<br>简单的dockerfile:</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> centos:<span class="hljs-number">7</span><br></code></pre></td></tr></table></figure><p>简单的docker build命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker build -t <span class="hljs-built_in">test</span> .<br></code></pre></td></tr></table></figure><p><code>-t</code>命令是指给镜像加一个tag名，对于镜像的识别除了依靠分配的十六进制的ID，主要依靠tag名，不同的tag在dockerhub中意味着不同的镜像。</p><p>我们可以使用<code>docker image ls</code>查看创建的镜像目录，可以看到有两个镜像，一个是我们从<a href="docker.io">docker.io</a>中拉取的centos7镜像，另一个是我们加了tag之后的镜像。</p><p><img src="https://link.jscdn.cn/1drv/aHR0cHM6Ly8xZHJ2Lm1zL3UvcyFBa3A3T0FGTWxmRUtoOUVvTkozUEZhU2NiVm9NN1E_ZT1FNkRCNVg.png" alt="docker image ls"></p><h3 id="根据镜像创建容器"><a href="#根据镜像创建容器" class="headerlink" title="根据镜像创建容器"></a>根据镜像创建容器</h3><p>现在有了镜像我们可以根据镜像创建容器。可以查看官方文档：<a href="https://docs.docker.com/engine/reference/run/">docker run reference</a>。</p><p>基础的<code>docker run</code>命令有如下的形式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run [OPTIONS] IMAGE[:TAG|@DIGEST] [COMMAND] [ARG...]<br></code></pre></td></tr></table></figure><p>镜像的开发者可以决定镜像的default设置：</p><ul><li>前台还是后台运行</li><li>容器识别</li><li>网络设置</li><li>运行时的约束如CPU和内存</li></ul><p><code>docker run</code>命令可以重写覆盖镜像的几乎所有缺省设置，这也是为什么这条命令比其他docker命令复杂的原因。</p><h3 id="容器的命令和交互"><a href="#容器的命令和交互" class="headerlink" title="容器的命令和交互"></a>容器的命令和交互</h3><p>在detached的模式下，当<code>docker run</code>运行容器的进程结束时，容器也会进入exited的状态。如果再加上<code>-rm</code>命令，则<code>docker run</code>进程结束或者守护进程结束时就会进入exited状态。对于有些即时的服务，这条命令可以轻松实现服务结束container退出，然后简单销毁就可以了。</p><p><img src="https://link.jscdn.cn/1drv/aHR0cHM6Ly8xZHJ2Lm1zL3UvcyFBa3A3T0FGTWxmRUtoOUV3NUFtYWliZTluUk5zTEE_ZT10WlNuN1M.png" alt="docker run -d"></p><p>如果不加<code>-d</code>命令，容器就会处于foreground模式，有如下选项：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-string">-a=[]</span>           <span class="hljs-string">:</span> <span class="hljs-string">Attach</span> <span class="hljs-string">to</span> <span class="hljs-string">`STDIN`,</span> <span class="hljs-string">`STDOUT`</span> <span class="hljs-string">and/or</span> <span class="hljs-string">`STDERR`</span><br><span class="hljs-string">-t</span>              <span class="hljs-string">:</span> <span class="hljs-string">Allocate</span> <span class="hljs-string">a</span> <span class="hljs-string">pseudo-tty</span><br><span class="hljs-string">--sig-proxy=true:</span> <span class="hljs-string">Proxy</span> <span class="hljs-string">all</span> <span class="hljs-string">received</span> <span class="hljs-string">signals</span> <span class="hljs-string">to</span> <span class="hljs-string">the</span> <span class="hljs-string">process</span> <span class="hljs-string">(non-TTY</span> <span class="hljs-string">mode</span> <span class="hljs-string">only)</span><br><span class="hljs-string">-i</span>              <span class="hljs-string">:</span> <span class="hljs-string">Keep</span> <span class="hljs-string">STDIN</span> <span class="hljs-string">open</span> <span class="hljs-string">even</span> <span class="hljs-string">if</span> <span class="hljs-string">not</span> <span class="hljs-string">attached</span><br></code></pre></td></tr></table></figure><p>通常会使用<code>-it</code>表示开启一个可交互的tty。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">(base) [coldison@localhost ~]$ docker run -it  <span class="hljs-built_in">test</span> /bin/bash<br>[root@2bc4bad23cac /]<span class="hljs-comment"># ls</span><br>anaconda-post.log  bin  dev  etc  home  lib  lib64  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var<br>[root@2bc4bad23cac ~]<span class="hljs-comment"># exit</span><br><span class="hljs-built_in">exit</span><br>(base) [coldison@localhost ~]$<br></code></pre></td></tr></table></figure><p>输入<code>exit</code>或者键盘命令<code>Ctrl+D</code>就可以退出tty。可以使用<code>docker attach</code>命令进入正在执行某个命令的终端，不能在其中操作；多个窗口同时attach到同一个容器时，所有窗口同步显示；当某个窗口因命令阻塞，其他窗口也无法操作。简而言之，attach命令实际上是绑定到<code>ENTRYPOINT/CMD</code>进程的输入输出流上，因此通常难以交互。</p><p>我们可以使用<code>docker exec</code>命令进行替代，参见官方文档<a href="https://docs.docker.com/engine/reference/commandline/exec/">docker exec</a>。</p><p><code>docker exec</code>命令的格式为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker <span class="hljs-built_in">exec</span> [OPTIONS] CONTAINER COMMAND [ARG...]<br></code></pre></td></tr></table></figure><p>实际上也就是<code>docker run</code>命令省去创建CONTAINER的过程。OPTIONS如下：</p><table><thead><tr><th align="left">Name, shorthand</th><th align="left">Default</th><th align="left">Description</th></tr></thead><tbody><tr><td align="left">–detach , -d</td><td align="left"></td><td align="left">Detached mode: run command in the background</td></tr><tr><td align="left">–detach-keys</td><td align="left"></td><td align="left">Override the key sequence for detaching a container</td></tr><tr><td align="left">–env , -e</td><td align="left"></td><td align="left">Set environment variables</td></tr><tr><td align="left">–env-file</td><td align="left"></td><td align="left">Read in a file of environment variables</td></tr><tr><td align="left">–interactive , -i</td><td align="left"></td><td align="left">Keep STDIN open even if not attached</td></tr><tr><td align="left">–privileged</td><td align="left"></td><td align="left">Give extended privileges to the command</td></tr><tr><td align="left">–tty , -t</td><td align="left"></td><td align="left">Allocate a pseudo-TTY</td></tr><tr><td align="left">–user , -u</td><td align="left"></td><td align="left">Username or UID (format: &lt;name</td></tr><tr><td align="left">–workdir , -w</td><td align="left"></td><td align="left">Working directory inside the container</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">(base) [coldison@localhost ~]$ docker <span class="hljs-built_in">exec</span> -it 158e7b0112e1 /bin/bash<br>[root@158e7b0112e1 /]<span class="hljs-comment"># ls</span><br>anaconda-post.log  dev  home  lib64  mnt  proc  run   srv  tmp  var<br>bin                etc  lib   media  opt  root  sbin  sys  usr<br>[root@158e7b0112e1 /]<span class="hljs-comment"># (base) [coldison@localhost ~]$</span><br>(base) [coldison@localhost ~]$ docker <span class="hljs-built_in">exec</span> -it 158e7b0112e1 /bin/bash<br>[root@158e7b0112e1 /]<span class="hljs-comment"># exit</span><br></code></pre></td></tr></table></figure><p><code>158e7b0112e1</code>是<code>CONTAINER ID</code>。需要注意的是，一定要加上执行的命令，并且这条命令的进程是容器的主进程之外的一条进程。此时加上<code>-d</code>参数就可以完成一些即时的命令。</p><h3 id="docker-run-reference其余基本设置"><a href="#docker-run-reference其余基本设置" class="headerlink" title="docker run reference其余基本设置"></a>docker run reference其余基本设置</h3><p>在官方文档的<a href="https://docs.docker.com/engine/reference/run/">docker run reference</a>中，与detached&amp;foreground平级的还有其他一些基本的概念与设置，这对于我们理解和使用docker非常有帮助。</p><h4 id="Container-Identification"><a href="#Container-Identification" class="headerlink" title="Container Identification"></a>Container Identification</h4><p>操作者可以用如下三种方式识别容器：</p><table><thead><tr><th align="left">Identifier</th><th align="left">type</th><th align="left">Example value</th></tr></thead><tbody><tr><td align="left">UUID long identifier</td><td align="left"></td><td align="left">“f78375b1c487e03c9438c729345e54db9d20cfa2ac1fc3494b6eb60872e74778”</td></tr><tr><td align="left">UUID short identifier</td><td align="left"></td><td align="left">“f78375b1c487”</td></tr><tr><td align="left">Name</td><td align="left"></td><td align="left">“evil_ptolemy”</td></tr></tbody></table><p>其中如果没有使用<code>--name</code>来给容器命名，那么docker守护进程会自动给容器分配一个名字。</p><p>也可以将容器的ID输出到文件中：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-string">--cidfile=&quot;&quot;:</span> <span class="hljs-string">Write</span> <span class="hljs-string">the</span> <span class="hljs-string">container</span> <span class="hljs-string">ID</span> <span class="hljs-string">to</span> <span class="hljs-string">the</span> <span class="hljs-string">file</span><br></code></pre></td></tr></table></figure><h4 id="Image-Identification"><a href="#Image-Identification" class="headerlink" title="Image Identification"></a>Image Identification</h4><p>image的引用遵循<code>image[:tag]</code>的形式，如<code>docker run ubuntu:14.04</code>。</p><p>采用v2或者更新的镜像格式的镜像还有一个内容可识别标识符（digest），也就是基于镜像的内容生成加密哈希串。为了避免从公共仓库pull下来的有被人篡改，可以在pull镜像的时候使用<code>image[@digest]</code>格式，如</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run alpine@sha256:9cacb71397b640eca97488cf08582ae4e4068513101088e9f96c9814bfda95e0 date<br></code></pre></td></tr></table></figure><p>当在pull镜像的时候，会根据镜像的内容计算digest，如果跟我们写入的不相符，就意味着包被人篡改了。</p><h4 id="PID-settings-–pid"><a href="#PID-settings-–pid" class="headerlink" title="PID settings (–pid)"></a>PID settings (–pid)</h4><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-string">--pid=&quot;&quot;</span>  <span class="hljs-string">:</span> <span class="hljs-string">Set</span> <span class="hljs-string">the</span> <span class="hljs-string">PID</span> <span class="hljs-string">(Process)</span> <span class="hljs-string">Namespace</span> <span class="hljs-string">mode</span> <span class="hljs-string">for</span> <span class="hljs-string">the</span> <span class="hljs-string">container,</span><br>             <span class="hljs-string">&#x27;container:&lt;name|id&gt;&#x27;</span><span class="hljs-string">:</span> <span class="hljs-string">joins</span> <span class="hljs-string">another</span> <span class="hljs-string">container&#x27;s</span> <span class="hljs-string">PID</span> <span class="hljs-string">namespace</span><br>             <span class="hljs-attr">&#x27;host&#x27;:</span> <span class="hljs-string">use</span> <span class="hljs-string">the</span> <span class="hljs-string">host&#x27;s</span> <span class="hljs-string">PID</span> <span class="hljs-string">namespace</span> <span class="hljs-string">inside</span> <span class="hljs-string">the</span> <span class="hljs-string">container</span><br></code></pre></td></tr></table></figure><p>容器的进程默认开启自己的命名空间，但是也可以使用<code>--pid</code>加入host或者其余容器的命名空间。如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run -it --rm --pid=host myhtop<br></code></pre></td></tr></table></figure><p>加入其它容器的进程空间可以用来为容器debug。如下图，redis这部分我暂时还不太清楚，因此看看就好：<br><img src="https://link.jscdn.cn/1drv/aHR0cHM6Ly8xZHJ2Lm1zL3UvcyFBa3A3T0FGTWxmRUtoOUY1eXQzakRWdlFvRXpDWmc_ZT1McHY0WUY.png" alt="redis container debug"></p><h4 id="UTS-settings-–uts"><a href="#UTS-settings-–uts" class="headerlink" title="UTS settings (–uts)"></a>UTS settings (–uts)</h4><p>UTS命名空间用来设置命名空间中可见的运行进程hostname和domain，默认每个容器，包括<code>--network=host</code>也有自己的UTS命名空间，当<code>--uts=host</code>时容器使用与host一样的UTS命名空间，而此时<code>--hostname</code>和<code>--domainname</code>设置不再有效。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-string">--uts=&quot;&quot;</span>  <span class="hljs-string">:</span> <span class="hljs-string">Set</span> <span class="hljs-string">the</span> <span class="hljs-string">UTS</span> <span class="hljs-string">namespace</span> <span class="hljs-string">mode</span> <span class="hljs-string">for</span> <span class="hljs-string">the</span> <span class="hljs-string">container,</span><br>       <span class="hljs-attr">&#x27;host&#x27;:</span> <span class="hljs-string">use</span> <span class="hljs-string">the</span> <span class="hljs-string">host&#x27;s</span> <span class="hljs-string">UTS</span> <span class="hljs-string">namespace</span> <span class="hljs-string">inside</span> <span class="hljs-string">the</span> <span class="hljs-string">container</span><br></code></pre></td></tr></table></figure><h4 id="IPC-settings-–ipc"><a href="#IPC-settings-–ipc" class="headerlink" title="IPC settings (–ipc)"></a>IPC settings (–ipc)</h4><p>IPC(POSIX/SysV IPC)命名空间提供了命名的共享内存片段、信号和消息队列<a href="https://docs.docker.com/engine/reference/run/#IPC%20settings:~:text=shared%20memory%20segments%2C%20semaphores%20and%20message%20queues">(shared memory segments, semaphores, and message queues)</a>。共享内存片段用于以内存级别的速度进程间的通信而非通过网络堆栈，经常被用在数据库或者定制的科学计算和金融服务业的高性能应用。如果这些应用被分解成多个容器，那么就需要共享容器的IPC机制。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-string">--ipc=&quot;MODE&quot;</span>  <span class="hljs-string">:</span> <span class="hljs-string">Set</span> <span class="hljs-string">the</span> <span class="hljs-string">IPC</span> <span class="hljs-string">mode</span> <span class="hljs-string">for</span> <span class="hljs-string">the</span> <span class="hljs-string">container</span><br></code></pre></td></tr></table></figure><p>值的设置如下：</p><table><thead><tr><th align="left">Value</th><th align="left">Description</th></tr></thead><tbody><tr><td align="left">“”</td><td align="left">Use daemon’s default.</td></tr><tr><td align="left">“none”</td><td align="left">Own private IPC namespace, with /dev/shm not mounted.</td></tr><tr><td align="left">“private”</td><td align="left">Own private IPC namespace.</td></tr><tr><td align="left">“shareable”</td><td align="left">Own private IPC namespace, with a possibility to share it with other containers.</td></tr><tr><td align="left">“container: &lt;_name-or-ID_&gt;”</td><td align="left">Join another (“shareable”) container’s IPC namespace.</td></tr><tr><td align="left">“host”</td><td align="left">Use the host system’s IPC namespace.</td></tr></tbody></table><p>设置<code>--ipc=shareable</code>后容器的IPC命名空间可被共享。</p><h4 id="Network-settings"><a href="#Network-settings" class="headerlink" title="Network settings"></a><a href="https://docs.docker.com/engine/reference/run/#network-settings:~:text=for%20other%20containers.-,Network%20settings%F0%9F%94%97,-%2D%2Ddns%3D%5B%5D%20%20%20%20%20%20%20%20%20%20%20%3A%20Set%20custom">Network settings</a></h4><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-string">--dns=[]</span>           <span class="hljs-string">:</span> <span class="hljs-string">Set</span> <span class="hljs-string">custom</span> <span class="hljs-string">dns</span> <span class="hljs-string">servers</span> <span class="hljs-string">for</span> <span class="hljs-string">the</span> <span class="hljs-string">container</span><br><span class="hljs-string">--network=&quot;bridge&quot;</span> <span class="hljs-string">:</span> <span class="hljs-string">Connect</span> <span class="hljs-string">a</span> <span class="hljs-string">container</span> <span class="hljs-string">to</span> <span class="hljs-string">a</span> <span class="hljs-string">network</span><br>                      <span class="hljs-attr">&#x27;bridge&#x27;:</span> <span class="hljs-string">create</span> <span class="hljs-string">a</span> <span class="hljs-string">network</span> <span class="hljs-string">stack</span> <span class="hljs-string">on</span> <span class="hljs-string">the</span> <span class="hljs-string">default</span> <span class="hljs-string">Docker</span> <span class="hljs-string">bridge</span><br>                      <span class="hljs-attr">&#x27;none&#x27;:</span> <span class="hljs-literal">no</span> <span class="hljs-string">networking</span><br>                      <span class="hljs-string">&#x27;container:&lt;name|id&gt;&#x27;</span><span class="hljs-string">:</span> <span class="hljs-string">reuse</span> <span class="hljs-string">another</span> <span class="hljs-string">container&#x27;s</span> <span class="hljs-string">network</span> <span class="hljs-string">stack</span><br>                      <span class="hljs-attr">&#x27;host&#x27;:</span> <span class="hljs-string">use</span> <span class="hljs-string">the</span> <span class="hljs-string">Docker</span> <span class="hljs-string">host</span> <span class="hljs-string">network</span> <span class="hljs-string">stack</span><br>                      <span class="hljs-string">&#x27;&lt;network-name&gt;|&lt;network-id&gt;&#x27;</span><span class="hljs-string">:</span> <span class="hljs-string">connect</span> <span class="hljs-string">to</span> <span class="hljs-string">a</span> <span class="hljs-string">user-defined</span> <span class="hljs-string">network</span><br><span class="hljs-string">--network-alias=[]</span> <span class="hljs-string">:</span> <span class="hljs-string">Add</span> <span class="hljs-string">network-scoped</span> <span class="hljs-string">alias</span> <span class="hljs-string">for</span> <span class="hljs-string">the</span> <span class="hljs-string">container</span><br><span class="hljs-string">--add-host=&quot;&quot;</span>      <span class="hljs-string">:</span> <span class="hljs-string">Add</span> <span class="hljs-string">a</span> <span class="hljs-string">line</span> <span class="hljs-string">to</span> <span class="hljs-string">/etc/hosts</span> <span class="hljs-string">(host:IP)</span><br><span class="hljs-string">--mac-address=&quot;&quot;</span>   <span class="hljs-string">:</span> <span class="hljs-string">Sets</span> <span class="hljs-string">the</span> <span class="hljs-string">container&#x27;s</span> <span class="hljs-string">Ethernet</span> <span class="hljs-string">device&#x27;s</span> <span class="hljs-string">MAC</span> <span class="hljs-string">address</span><br><span class="hljs-string">--ip=&quot;&quot;</span>            <span class="hljs-string">:</span> <span class="hljs-string">Sets</span> <span class="hljs-string">the</span> <span class="hljs-string">container&#x27;s</span> <span class="hljs-string">Ethernet</span> <span class="hljs-string">device&#x27;s</span> <span class="hljs-string">IPv4</span> <span class="hljs-string">address</span><br><span class="hljs-string">--ip6=&quot;&quot;</span>           <span class="hljs-string">:</span> <span class="hljs-string">Sets</span> <span class="hljs-string">the</span> <span class="hljs-string">container&#x27;s</span> <span class="hljs-string">Ethernet</span> <span class="hljs-string">device&#x27;s</span> <span class="hljs-string">IPv6</span> <span class="hljs-string">address</span><br><span class="hljs-string">--link-local-ip=[]</span> <span class="hljs-string">:</span> <span class="hljs-string">Sets</span> <span class="hljs-string">one</span> <span class="hljs-string">or</span> <span class="hljs-string">more</span> <span class="hljs-string">container&#x27;s</span> <span class="hljs-string">Ethernet</span> <span class="hljs-string">device&#x27;s</span> <span class="hljs-string">link</span> <span class="hljs-string">local</span> <span class="hljs-string">IPv4/IPv6</span> <span class="hljs-string">addresses</span><br></code></pre></td></tr></table></figure><p>容器的network默认开启并且可以进行任何outgoing的连接，可以使用<code>docker run --network none</code>关闭outgoing和incoming的网络连接，这样的话容器只能通过文件或者<code>STDIN</code>和<code>STDOUT</code>进行IO。<strong>开放端口和连接其他的容器</strong>只能在bridge模式下进行，也就是连接到docker本身的网络驱动，一般也更偏向这种方式。<code>--dns</code>命令也可以改写DNS。默认情况下MAC地址是根据分配给容器的IP生成，也可以通过<code>--mac-address</code>来改写，docker不会确认MAC地址是否是<strong>唯一</strong>的。</p><p>具体设置：</p><table><thead><tr><th align="left">Network</th><th align="left">Description</th></tr></thead><tbody><tr><td align="left">none</td><td align="left">No networking in the container.</td></tr><tr><td align="left">bridge(default)</td><td align="left">Connect the container to the bridge via veth interfaces.</td></tr><tr><td align="left">host</td><td align="left">Use the host’s network stack inside the container.</td></tr><tr><td align="left">container:&lt;name</td><td align="left">id&gt;</td></tr><tr><td align="left">NETWORK</td><td align="left">Connects the container to a user created network (using docker network create command)</td></tr></tbody></table><p>不同的模式还有一些细节，这里不再赘述。</p><h4 id="Restart-policies-–restart"><a href="#Restart-policies-–restart" class="headerlink" title="Restart policies (–restart)"></a>Restart policies (–restart)</h4><p><code>--restart</code>命令用于指定容器在exit之后的重启策略，具体策略如下：</p><table><thead><tr><th align="left">Policy</th><th align="left">Result</th></tr></thead><tbody><tr><td align="left">no</td><td align="left">Do not automatically restart the container when it exits. This is the default.</td></tr><tr><td align="left">on-failure[:max-retries]</td><td align="left">Restart only if the container exits with a non-zero exit status. Optionally, limit the number of restart retries the Docker daemon attempts.</td></tr><tr><td align="left">always</td><td align="left">Always restart the container regardless of the exit status. When you specify always, the Docker daemon will try to restart the container indefinitely. The container will also always start on daemon startup, regardless of the current state of the container.</td></tr><tr><td align="left">unless-stopped</td><td align="left">Always restart the container regardless of the exit status, including on daemon startup, except if the container was put into a stopped state before the Docker daemon was stopped.</td></tr></tbody></table><p>在重启时，为了防止服务器过载，daemon会采取延时启动的方式，从100ms开始，不断double知道达到<code>on-failure</code>限制或者最大延时1min，或者<code>docker stop</code>或者<code>docker rm -f</code>。</p><p>如果一个容器成功重启（也就是started并且成功运行至少10s），上述的时延会被重置为100ms。在<code>on-faliure</code>的模式下可以设置最大重启次数，默认是无限次。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run --restart=on-failure:10 redis<br></code></pre></td></tr></table></figure><p>可以使用<code>docker inspect</code>来确认一个容器重启了多少次：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker inspect -f <span class="hljs-string">&quot;&#123;&#123;.RestartCount&#125;&#125;&quot;</span> my-container<br></code></pre></td></tr></table></figure><p>或者上一次启动时间：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker inspect -f <span class="hljs-string">&quot;&#123;&#123;.State.StartedAt&#125;&#125;&quot;</span> my-container<br></code></pre></td></tr></table></figure><h4 id="Exit-Status"><a href="#Exit-Status" class="headerlink" title="Exit Status"></a>Exit Status</h4><p>当<code>docker run</code>无法运行或者退出的时候，会返回一个错误码：</p><table><thead><tr><th align="left">错误码</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">125</td><td align="left">docker守护进程错误，指docker run命令本身有问题</td></tr><tr><td align="left">126</td><td align="left">容器的命令无法唤起</td></tr><tr><td align="left">127</td><td align="left">容器的命令无法被找到</td></tr><tr><td align="left">other</td><td align="left">其余的命令错误码可以指定，如<code>docker run busybox /bin/sh -c &quot;exit 3</code></td></tr></tbody></table><h4 id="Clean-up-–rm"><a href="#Clean-up-–rm" class="headerlink" title="Clean up (–rm)"></a>Clean up (–rm)</h4><p>默认情形下，容器退出之后，其文件系统仍旧保留，这方便我们debug，但是如果是运行短时的foreground进程，那么文件就会非常容易堆积。<code>--rm</code>标识会使docker自动清理容器并且在容器退出时移除文件系统。<code>--rm</code>会移除和容器相关的<strong>匿名空间</strong>，与<code>docker rm -v my-container</code>命令类似 。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run --rm -v /foo -v awesome:/bar busybox top<br></code></pre></td></tr></table></figure><p>上述的命令中，<code>/foo</code>文件夹会被移除但是<code>/bar</code>会被保留。</p><h4 id="Security-configuration"><a href="#Security-configuration" class="headerlink" title="Security configuration"></a>Security configuration</h4><table><thead><tr><th align="left">Option</th><th align="left">Description</th></tr></thead><tbody><tr><td align="left">–security-opt=”label=user:USER”</td><td align="left">Set the label user for the container</td></tr><tr><td align="left">–security-opt=”label=role:ROLE”</td><td align="left">Set the label role for the container</td></tr><tr><td align="left">–security-opt=”label=type:TYPE”</td><td align="left">Set the label type for the container</td></tr><tr><td align="left">–security-opt=”label=level:LEVEL”</td><td align="left">Set the label level for the container</td></tr><tr><td align="left">–security-opt=”label=disable”</td><td align="left">Turn off label confinement for the container</td></tr><tr><td align="left">–security-opt=”apparmor=PROFILE”</td><td align="left">Set the apparmor profile to be applied to the container</td></tr><tr><td align="left">–security-opt=”no-new-privileges:true”</td><td align="left">Disable container processes from gaining new privileges</td></tr><tr><td align="left">–security-opt=”seccomp=unconfined”</td><td align="left">Turn off seccomp confinement for the container</td></tr><tr><td align="left">–security-opt=”seccomp=profile.json”</td><td align="left">White-listed syscalls seccomp Json file to be used as a seccomp filter</td></tr></tbody></table><p>这里的安全策略，也就是容器允许使用的权限，需要自行定义。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run --security-opt label=<span class="hljs-built_in">disable</span> -it fedora bash<br></code></pre></td></tr></table></figure><p>容器disbale安全选项。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run --security-opt  no-new-priviledges -it centos bash<br></code></pre></td></tr></table></figure><p>阻止容器获得更多权限，这种情形下<code>su</code>或者<code>sudo</code>不再有用。</p><h4 id="Specify-an-init-process"><a href="#Specify-an-init-process" class="headerlink" title="Specify an init process"></a>Specify an init process</h4><p><code>--init</code>可以指定容器中运行的PID为1的进程，默认是<code>docker-init</code>。</p><h4 id="Specify-custom-cgroups-自定义cgroups"><a href="#Specify-custom-cgroups-自定义cgroups" class="headerlink" title="Specify custom cgroups/自定义cgroups"></a>Specify custom cgroups/自定义cgroups</h4><p><code>--cgroup-parent</code>参数可以给容器指定一个特定的cgroup，然后可以自定义cgroup可以使用的资源。</p><h4 id="资源约束"><a href="#资源约束" class="headerlink" title="资源约束"></a>资源约束</h4><ol><li><p><a href="https://docs.docker.com/engine/reference/run/#network-settings:~:text=common%20parent%20group.-,Runtime%20constraints%20on%20resources,-%F0%9F%94%97">运行时资源约束/Runtime constraints on resources</a>，如内存、CPU等等，用于调整容器的表现，由于设置比较多，给一个链接在这里。</p></li><li><p><a href="https://docs.docker.com/engine/reference/run/#network-settings:~:text=Runtime%20constraints%20on%20resources%F0%9F%94%97">用户内存约束</a></p></li><li><p><a href="https://docs.docker.com/engine/reference/run/%E3%80%82#network-settings:~:text=Kernel%20memory%20constraints%F0%9F%94%97">核内存约束/Kernel memory constraints</a></p></li><li><p><a href="https://docs.docker.com/engine/reference/run/#network-settings:~:text=CPU%20period%20constraint">CPU共享约束/CPU share constraints</a>，默认状态下，所有的容器有相同比例的CPU时间片，但是我们可以通过设置比例来调整每个容器所使用的的CPU时间。</p></li><li><p><a href="https://docs.docker.com/engine/reference/run/#network-settings:~:text=100%25%20of%20CPU2-,CPU%20period%20constraint,-%F0%9F%94%97">CPU周期与比例约束/CPU period&amp;quota constraint</a>，约束容器使用的CPU周期的比例。</p></li><li><p><a href="https://docs.docker.com/engine/reference/run/#network-settings:~:text=bandwidth%20limiting.-,Cpuset%20constraint,-%F0%9F%94%97">CPU核约束/Cpuset constraint</a>，选择容器使用的CPU核，同样也能够约束容器使用的内存。</p></li><li><p><a href="https://docs.docker.com/engine/reference/run/#network-settings:~:text=bandwidth%20limiting.-,Block%20IO%20bandwidth%20(Blkio)%20constraint,-%F0%9F%94%97">阻塞IO带宽约束/Block IO bandwidth(Blkio) constraint</a>，设置容器的阻塞通信时间权重，可以具体到某一个设备，包括设备的读写和IO。</p></li></ol><h4 id="用户组"><a href="#用户组" class="headerlink" title="用户组"></a>用户组</h4><p>docker容器进程默认在特定的用户的补充用户组中运行，可以使用如下命令增加用户组。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run --rm --group-add audio --group-add nogroup --group-add 777 busybox id<br></code></pre></td></tr></table></figure><h4 id="运行时权限和Linux能力-Runtime-privilege-and-Linux-capabilities"><a href="#运行时权限和Linux能力-Runtime-privilege-and-Linux-capabilities" class="headerlink" title="运行时权限和Linux能力/Runtime privilege and Linux capabilities"></a>运行时权限和Linux能力/<a href="https://docs.docker.com/engine/reference/run/#network-settings:~:text=99(nogroup)%2C777-,Runtime%20privilege%20and%20Linux%20capabilities,-%F0%9F%94%97">Runtime privilege and Linux capabilities</a></h4><table><thead><tr><th align="left">Option</th><th align="left">Description</th></tr></thead><tbody><tr><td align="left">–cap-add</td><td align="left">Add Linux capabilities</td></tr><tr><td align="left">–cap-drop</td><td align="left">Drop Linux capabilities</td></tr><tr><td align="left">–privileged</td><td align="left">Give extended privileges to this container</td></tr><tr><td align="left">–device=[]</td><td align="left">Allows you to run devices inside the container without the –privileged flag.</td></tr></tbody></table><p>在默认情况下，Docker容器是没有特权的，因此不被允许去接入任何的设备，而<code>--privileged</code>则允许容器接入所有设备，<code>--device</code>则是指定接入特定设备，可以<code>read</code>，<code>write</code>，<code>mknod</code>。还可以通过<code>--cap-add</code>和<code>--cap-drop</code>增加更多linux系统级的能力，这里就不单独列出。</p><h4 id="日志驱动-Logging-drivers-–log-driver"><a href="#日志驱动-Logging-drivers-–log-driver" class="headerlink" title="日志驱动/Logging drivers (–log-driver)"></a>日志驱动/Logging drivers (–log-driver)</h4><p>容器可以选择跟daemon不同的日志驱动。</p><h4 id="覆盖Dockerfile镜像默认设置"><a href="#覆盖Dockerfile镜像默认设置" class="headerlink" title="覆盖Dockerfile镜像默认设置"></a>覆盖Dockerfile镜像默认设置</h4><p>当基于Dockerfile创建镜像时，开发者会有一系列的默认设置，除了<code>FROM</code>，<code>RUN</code>，<code>MAINTAINER</code>，<code>ADD</code>之外的命令都可以在<code>docker run</code>中覆盖。我们可以一条一条来看。</p><ol><li><p>CMD(默认命令或者选项)</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run [OPTIONS] IMAGE[:TAG|@DIGEST] [COMMAND] [ARG...]<br></code></pre></td></tr></table></figure><p> 创建IMAGE的开发者会用Dockerfile中的CMD命令提供默认的COMMAND指令。</p></li><li><p>ENTRYPOINT(运行时默认执行命令)<br> ENTRYPOINT是容器运行时必须执行的命令，有了ENTRYPOINT之后CMD命令的作用是为ENTRYPOINT传入更多的参数。可以使用<code>--entrypoint</code>参数改写镜像的ENTRYPOINT，如：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run -it --entrypoint /bin/bash example/redis<br></code></pre></td></tr></table></figure><p> 使用COMMAND为ENTRYPOINT传入更多的参数：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run -it --entrypoint /bin/bash example/redis -c ls -l<br>docker run -it --entrypoint /usr/bin/redis-cli example/redis --<span class="hljs-built_in">help</span><br></code></pre></td></tr></table></figure><p> 或者传入一个空的ENTRYPOINT：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run -it --entrypoint=<span class="hljs-string">&quot;&quot;</span> mysql bash<br></code></pre></td></tr></table></figure></li><li><p>EXPOSE(外部接入的端口)</p> <figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-string">--expose=[]:</span> <span class="hljs-string">Expose</span> <span class="hljs-string">a</span> <span class="hljs-string">port</span> <span class="hljs-string">or</span> <span class="hljs-string">a</span> <span class="hljs-string">range</span> <span class="hljs-string">of</span> <span class="hljs-string">ports</span> <span class="hljs-string">inside</span> <span class="hljs-string">the</span> <span class="hljs-string">container.</span><br>            <span class="hljs-string">These</span> <span class="hljs-string">are</span> <span class="hljs-string">additional</span> <span class="hljs-string">to</span> <span class="hljs-string">those</span> <span class="hljs-string">exposed</span> <span class="hljs-string">by</span> <span class="hljs-string">the</span> <span class="hljs-string">`EXPOSE`</span> <span class="hljs-string">instruction</span><br><span class="hljs-string">-P</span>         <span class="hljs-string">:</span> <span class="hljs-string">Publish</span> <span class="hljs-string">all</span> <span class="hljs-string">exposed</span> <span class="hljs-string">ports</span> <span class="hljs-string">to</span> <span class="hljs-string">the</span> <span class="hljs-string">host</span> <span class="hljs-string">interfaces</span><br><span class="hljs-string">-p=[]</span>      <span class="hljs-string">:</span> <span class="hljs-string">Publish</span> <span class="hljs-string">a</span> <span class="hljs-string">container&#x27;s</span> <span class="hljs-string">port</span> <span class="hljs-string">or</span> <span class="hljs-string">a</span> <span class="hljs-string">range</span> <span class="hljs-string">of</span> <span class="hljs-string">ports</span> <span class="hljs-string">to</span> <span class="hljs-string">the</span> <span class="hljs-string">host</span><br>            <span class="hljs-attr">format:</span> <span class="hljs-string">ip:hostPort:containerPort</span> <span class="hljs-string">|</span> <span class="hljs-string">ip::containerPort</span> <span class="hljs-string">|</span> <span class="hljs-string">hostPort:containerPort</span> <span class="hljs-string">|</span> <span class="hljs-string">containerPort</span><br>            <span class="hljs-string">Both</span> <span class="hljs-string">hostPort</span> <span class="hljs-string">and</span> <span class="hljs-string">containerPort</span> <span class="hljs-string">can</span> <span class="hljs-string">be</span> <span class="hljs-string">specified</span> <span class="hljs-string">as</span> <span class="hljs-string">a</span><br>            <span class="hljs-string">range</span> <span class="hljs-string">of</span> <span class="hljs-string">ports.</span> <span class="hljs-string">When</span> <span class="hljs-string">specifying</span> <span class="hljs-string">ranges</span> <span class="hljs-string">for</span> <span class="hljs-string">both,</span> <span class="hljs-string">the</span><br>            <span class="hljs-string">number</span> <span class="hljs-string">of</span> <span class="hljs-string">container</span> <span class="hljs-string">ports</span> <span class="hljs-string">in</span> <span class="hljs-string">the</span> <span class="hljs-string">range</span> <span class="hljs-string">must</span> <span class="hljs-string">match</span> <span class="hljs-string">the</span><br>            <span class="hljs-string">number</span> <span class="hljs-string">of</span> <span class="hljs-string">host</span> <span class="hljs-string">ports</span> <span class="hljs-string">in</span> <span class="hljs-string">the</span> <span class="hljs-string">range,</span> <span class="hljs-attr">for example:</span><br>                <span class="hljs-string">-p</span> <span class="hljs-number">1234</span><span class="hljs-number">-1236</span><span class="hljs-string">:1234-1236/tcp</span><br><br>            <span class="hljs-string">When</span> <span class="hljs-string">specifying</span> <span class="hljs-string">a</span> <span class="hljs-string">range</span> <span class="hljs-string">for</span> <span class="hljs-string">hostPort</span> <span class="hljs-string">only,</span> <span class="hljs-string">the</span><br>            <span class="hljs-string">containerPort</span> <span class="hljs-string">must</span> <span class="hljs-string">not</span> <span class="hljs-string">be</span> <span class="hljs-string">a</span> <span class="hljs-string">range.</span>  <span class="hljs-string">In</span> <span class="hljs-string">this</span> <span class="hljs-string">case</span> <span class="hljs-string">the</span><br>            <span class="hljs-string">container</span> <span class="hljs-string">port</span> <span class="hljs-string">is</span> <span class="hljs-string">published</span> <span class="hljs-string">somewhere</span> <span class="hljs-string">within</span> <span class="hljs-string">the</span><br>            <span class="hljs-string">specified</span> <span class="hljs-string">hostPort</span> <span class="hljs-string">range.</span> <span class="hljs-string">(e.g.,</span> <span class="hljs-string">`-p</span> <span class="hljs-number">1234</span><span class="hljs-number">-1236</span><span class="hljs-string">:1234/tcp`)</span><br><br>            <span class="hljs-string">(use</span> <span class="hljs-string">&#x27;docker port&#x27;</span> <span class="hljs-string">to</span> <span class="hljs-string">see</span> <span class="hljs-string">the</span> <span class="hljs-string">actual</span> <span class="hljs-string">mapping)</span><br><br><span class="hljs-string">--link=&quot;&quot;</span>  <span class="hljs-string">:</span> <span class="hljs-string">Add</span> <span class="hljs-string">link</span> <span class="hljs-string">to</span> <span class="hljs-string">another</span> <span class="hljs-string">container</span> <span class="hljs-string">(&lt;name</span> <span class="hljs-string">or</span> <span class="hljs-string">id&gt;:alias</span> <span class="hljs-string">or</span> <span class="hljs-string">&lt;name</span> <span class="hljs-string">or</span> <span class="hljs-string">id&gt;)</span><br></code></pre></td></tr></table></figure><p> 暴露的端口会绑定到host的随机端口，可以使用<code>docker port</code>查看，<code>link</code>命令用于连接其他的容器，从而使用其他容器暴露的端口。</p></li><li><p>ENV(环境变量)</p><p> Docker不会设置windows容器的任何环境变量，以下是Linux容器的设置：</p><table><thead><tr><th align="left">Variable</th><th align="left">Value</th></tr></thead><tbody><tr><td align="left">HOME</td><td align="left">Set based on the value of USER</td></tr><tr><td align="left">HOSTNAME</td><td align="left">The hostname associated with the container</td></tr><tr><td align="left">PATH</td><td align="left">Includes popular directories, such as /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin</td></tr><tr><td align="left">TERM</td><td align="left">xterm if the container is allocated a pseudo-TTY</td></tr></tbody></table><p> <code>docker run</code>可以使用一个或者更多的<code>-e</code>来覆盖上述的环境变量。如果没有特别指定一个环境变量的值，那么环境变量将会到运行容器的环境中去寻找。</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> today=Wednesday<br>docker run -e <span class="hljs-string">&quot;deep=purple&quot;</span> -e today --rm alpine env<br></code></pre></td></tr></table></figure></li><li><p>HEALTHCHECK(健康检查)</p></li><li><p>TMPFS(挂载tmpfs文件系统)</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run -d --tmpfs /run:rw,noexec,nosuid,size=65536k my_image<br></code></pre></td></tr></table></figure></li><li><p>VOLUME(共享文件系统)</p></li><li><p>USER</p></li><li><p>WORKDIR</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>教程</category>
      
      <category>Docker使用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
      <tag>容器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>中秋节随感</title>
    <link href="/2022/09/10/%E4%B8%AD%E7%A7%8B%E8%8A%82%E9%9A%8F%E6%84%9F2022/"/>
    <url>/2022/09/10/%E4%B8%AD%E7%A7%8B%E8%8A%82%E9%9A%8F%E6%84%9F2022/</url>
    
    <content type="html"><![CDATA[<h3 id="（一）"><a href="#（一）" class="headerlink" title="（一）"></a>（一）</h3><p>又是一年中秋，似乎每一逢节日就变得多愁善感起来。实际上我也好久不写随笔，因为虽然时时体验着某种持续的深沉的忧郁，但是也排不出严肃的思绪，去思考什么样的问题。</p><p>人的本身总是很难的，要五讲四美，有七情六欲。三尸斩不断，反而显化和粘连，于是对自己发出到底是凡人的感叹。</p><p>仙凡当然是有别的，虽然清静经里说，大道无情，于是载道的仙人们也就冷酷。但是民俗的仙人们大多也就象是畏畏缩缩的官僚，威于自己的职能，此外便也就是蝇营狗苟，人情世故。所以也未必是仙。</p><p>另外一种是，生活状态的不同，也或者说是一种统治的需要。这一点上我们喜欢的，一种近乎于莫名其妙的故事，但是，通俗点说，就是封建桎梏的悲剧，便就是杨二郎，清源妙道真君。玉帝不喜欢自己的妹妹与凡人结合，因此将其镇压在华山之下。“天上一日，地上三年”，又是因为天庭礼法的约束，故而当属大逆不道。杨戬长大成人，便要开山救母，此名曰孝，后面又在天庭当差，忠孝于是两全了。沉香救母，也是同样的一种循环，只不过大恶人变成了二郎真君自己，最后又是一团和气。封神演义中话，杨戬是玉鼎真人的徒弟，练得有八九玄功，是横练的肉体，一身气力，耍三尖两刃枪，作为阐教的第三代弟子，相顾伐纣，足智多谋，战功赫赫，所以成圣称神。我当然看的是洪荒流小说，把两段统一起来，但是化到现代，可能也无非就是一段今日说法的故事。但是可以想见，救母的时候是仙凡有别，但是真君肉身成圣，也是凡人作仙，可见第一段时仙途断绝，天庭冗员。</p><p>有一类神我倒是很感兴趣，就是所谓的星君。在道门里，乃是天人感应所生，紫薇，太白，二十八宿，不知凡几。大抵凡有一颗亮星，便有一名神祇。道众们为这些人安排了各种各样的工作，有的在天庭当差，有的保命，有的护身，有的度厄，福禄寿，文曲武曲，也是星神。仿佛是基于一种逻辑上的推演，大多数星君们神通一般，所司之事也是玄之又玄，于是信众们似乎也仅仅止于上香祈福。道门中人倒是会用符箓来敕请这些大人，借用一些微不足道的神力，来斩妖除魔，解忧度厄。所以总体上，这些神也好像是无所事事，存在便就是一种神性。多数也没有固定的形象，有些如概念上的秉性特殊，或者朱雀白虎之类的，有图腾方位的神力。水浒中的天罡地煞，也仅仅是称号罢了，也是星神本身就是抽象虚无。但是也正因为此，星神们似乎是最具神性的，一种不依托与人本身的存在，或者说，当你知道他们是神仙的时候，他们便就是神仙了。其本真自性，便就是神，也就是大道的一点显化。</p><h3 id="（二）"><a href="#（二）" class="headerlink" title="（二）"></a>（二）</h3><p>仙，当然是可以修的。修仙的网络文学和道教的基础是差不多的，那就是天人感应的学说，外在的天地和内在的天地可以对应沟通。凡有一百零八，二百十六处窍穴，一一打通，便可以感应天地，出阳神，成为一种不朽的，玄之又玄的存在。为此，需要锻炼筋骨，强健肉身，还需冥想修行，打磨精神和道心。再有炼丹采药，道法神通。因为设定严丝合缝，所以才有各种异彩纷呈的作品。</p><p>还有一个有趣的地方在于，修仙固然是与大道相通，但是同样也是与大道排斥的。所以修仙者进阶就会有天劫。和九九八十一难这种混资历不同，天劫似乎也是感应而生，以雷罚为主，跟天庭的雷池概念相通，显其凌厉。但是多数情况下又是无因无果，渡劫者要么立有进境，要么身死道消。唯一得出的结论是，虽是大道无情，但是其却是有限的，所以大道越是在己，天道越是不喜。所谓大道三千，也是很多网文的设定。</p><h3 id="（三）"><a href="#（三）" class="headerlink" title="（三）"></a>（三）</h3><p>我自己倒是构思过很多类似的桥段。仙道渺渺，仙途难寻。</p><p>大约是隋唐时，彼时终南山便就是方士名流养望之所在。长安的小伙计，在攒了一些资材之后，决意去山中求仙。</p><p>庙宇香火不断，寻访几处，小伙计便有一种直觉，那就是所谓的世外高人们大多也时空谈之辈，仪典本身也并不能跟仙人沟通。所以去野观中修行，道长透露因缘际会得到一本册子，倒是会一些小法术，但是不得其门，也不想献宝，如今也就收徒传典。寿元将近，师徒二人决定出海寻仙。从长安出发，一路向东至秦皇求仙处。</p><p>一路艰难险阻，师父逝于海上。最终小伙计在海中遇见了蜃气所化之妖。虽然名妖，但是却是感应而生，善于化形。小伙计堪破红尘，见到了蜃本身，其却是避世有时，也属先天生灵，并不知晓什么仙人。于是二人一块上路……</p><p>大约是这样的一种故事。</p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>2022</tag>
      
      <tag>中秋</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>本地部署fauxpilot</title>
    <link href="/2022/08/19/%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2fauxpilot/"/>
    <url>/2022/08/19/%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2fauxpilot/</url>
    
    <content type="html"><![CDATA[<p>由于copilot决定要收费，而且代码上传到对面的服务器也存在安全上的疑虑。小伙伴给我推了<a href="https://github.com/moyix/fauxpilot">fauxpilot</a>，正好组里面显卡闲置，所以自己本地部署了一下。由于使用的是shell脚本，因此可能需要注意下不同系统的编码问题，直接在linux上git clone或者解压。</p><h3 id="包和依赖"><a href="#包和依赖" class="headerlink" title="包和依赖"></a>包和依赖</h3><ul><li>安装Docker。</li><li>安装docker compose &gt;= 1.28。Docker Compose是一个用来定义和运行复杂应用的Docker工具。一个使用Docker容器的应用，通常由多个容器组成。使用Docker Compose不再需要使用shell脚本来启动容器。 Compose 通过一个yml配置文件来管理多个Docker容器，在配置文件中，所有的容器通过services来定义，然后使用docker compose脚本来启动，停止和重启应用，和应用中的服务以及所有依赖服务的容器，非常适合组合使用多个容器进行开发的场景。</li><li>NVIDIA算力 &gt;= 7.0的GPU，根据显存选择合适的模型。</li><li>安装nvidia-docker，这是nvidia弄出的链接显卡的容器技术。</li><li>curl和zstd用于下载与解压模型，建议提前检查有没有安装。</li></ul><h3 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h3><p>参见README。</p><ol><li><p>运行 <code>bash setup.sh</code>，我习惯使用bash命令。按照提示，输入命令，该脚本会下载对应的模型并且配置config.env文件，主要是一些参数。以下是我的示例。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs config">MODEL&#x3D;codegen-2B-mono<br>NUM_GPUS&#x3D;1<br>MODEL_DIR&#x3D;&#x2F;data&#x2F;ds&#x2F;fauxpilot-main&#x2F;models<br></code></pre></td></tr></table></figure><p>如果要重新部署，需要先删除config.env文件，否则脚本还是会执行原本的配置。</p></li><li><p>运行 <code>bash launch.sh</code>。读取对应的参数并且执行 <code>docker compose</code>命令。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">version:</span> <span class="hljs-string">&#x27;3.3&#x27;</span><br><span class="hljs-attr">services:</span><br>    <span class="hljs-attr">triton:</span><br>        <span class="hljs-attr">image:</span> <span class="hljs-string">moyix/triton_with_ft:22.06</span><br>        <span class="hljs-attr">command:</span> <span class="hljs-string">bash</span> <span class="hljs-string">-c</span> <span class="hljs-string">&quot;CUDA_VISIBLE_DEVICES=$&#123;GPUS&#125; mpirun -n 1 --allow-run-as-root /opt/tritonserver/bin/tritonserver --model-repository=/model&quot;</span><br>        <span class="hljs-attr">shm_size:</span> <span class="hljs-string">&#x27;2gb&#x27;</span><br>        <span class="hljs-attr">volumes:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">$&#123;MODEL_DIR&#125;:/model</span><br>        <span class="hljs-attr">ports:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;8000:8000&quot;</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;8001:8001&quot;</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;8002:8002&quot;</span><br>        <span class="hljs-attr">deploy:</span><br>        <span class="hljs-attr">resources:</span><br>            <span class="hljs-attr">reservations:</span><br>            <span class="hljs-attr">devices:</span><br>                <span class="hljs-bullet">-</span> <span class="hljs-attr">driver:</span> <span class="hljs-string">nvidia</span><br>                <span class="hljs-attr">count:</span> <span class="hljs-string">all</span><br>                <span class="hljs-attr">capabilities:</span> [<span class="hljs-string">gpu</span>]<br>    <span class="hljs-attr">copilot_proxy:</span><br>        <span class="hljs-attr">image:</span> <span class="hljs-string">moyix/copilot_proxy:latest</span><br>        <span class="hljs-attr">command:</span> <span class="hljs-string">python3</span> <span class="hljs-string">-m</span> <span class="hljs-string">flask</span> <span class="hljs-string">run</span> <span class="hljs-string">--host=0.0.0.0</span> <span class="hljs-string">--port=5000</span><br>        <span class="hljs-attr">ports:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;5000:5000&quot;</span><br></code></pre></td></tr></table></figure><p>以上就是docker_compose.yml文件，可以看到主要运行了两个服务，一个推理服务，一个是flask网络应用。使用 <code>docker ps</code>可以查询是否正在运行。<br><img src="https://link.jscdn.cn/1drv/aHR0cHM6Ly8xZHJ2Lm1zL3UvcyFBa3A3T0FGTWxmRUtoNWdMN1N0N3VtdkZGVFo4cFE_ZT03VDlYaDI.png" alt="docker进程"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ./launch.sh <br>[+] Running 2/0<br>⠿ Container fauxpilot-triton-1         Created                                                                                                                                                                                                                                                                                             0.0s<br>⠿ Container fauxpilot-copilot_proxy-1  Created                                                                                                                                                                                                                                                                                             0.0s<br>Attaching to fauxpilot-copilot_proxy-1, fauxpilot-triton-1<br>fauxpilot-triton-1         | <br>fauxpilot-triton-1         | =============================<br>fauxpilot-triton-1         | == Triton Inference Server ==<br>fauxpilot-triton-1         | =============================<br>fauxpilot-triton-1         | <br>fauxpilot-triton-1         | NVIDIA Release 22.06 (build 39726160)<br>fauxpilot-triton-1         | Triton Server Version 2.23.0<br>fauxpilot-triton-1         | <br>fauxpilot-triton-1         | Copyright (c) 2018-2022, NVIDIA CORPORATION &amp; AFFILIATES.  All rights reserved.<br>fauxpilot-triton-1         | <br>fauxpilot-triton-1         | Various files include modifications (c) NVIDIA CORPORATION &amp; AFFILIATES.  All rights reserved.<br>fauxpilot-triton-1         | <br>fauxpilot-triton-1         | This container image and its contents are governed by the NVIDIA Deep Learning Container License.<br>fauxpilot-triton-1         | By pulling and using the container, you accept the terms and conditions of this license:<br>fauxpilot-triton-1         | https://developer.nvidia.com/ngc/nvidia-deep-learning-container-license<br>fauxpilot-copilot_proxy-1  | WARNING: This is a development server. Do not use it <span class="hljs-keyword">in</span> a production deployment. Use a production WSGI server instead.<br>fauxpilot-copilot_proxy-1  |  * Debug mode: off<br>fauxpilot-copilot_proxy-1  |  * Running on all addresses (0.0.0.0)<br>fauxpilot-copilot_proxy-1  |    WARNING: This is a development server. Do not use it <span class="hljs-keyword">in</span> a production deployment.<br>fauxpilot-copilot_proxy-1  |  * Running on http://127.0.0.1:5000<br>fauxpilot-copilot_proxy-1  |  * Running on http://172.18.0.3:5000 (Press CTRL+C to quit)<br>fauxpilot-triton-1         | <br>fauxpilot-triton-1         | ERROR: This container was built <span class="hljs-keyword">for</span> NVIDIA Driver Release 515.48 or later, but<br>fauxpilot-triton-1         |        version  was detected and compatibility mode is UNAVAILABLE.<br>fauxpilot-triton-1         | <br>fauxpilot-triton-1         |        [[]]<br>fauxpilot-triton-1         | <br>fauxpilot-triton-1         | I0803 01:51:02.690042 93 pinned_memory_manager.cc:240] Pinned memory pool is created at <span class="hljs-string">&#x27;0x7f6104000000&#x27;</span> with size 268435456<br>fauxpilot-triton-1         | I0803 01:51:02.690461 93 cuda_memory_manager.cc:105] CUDA memory pool is created on device 0 with size 67108864<br>fauxpilot-triton-1         | I0803 01:51:02.692434 93 model_repository_manager.cc:1191] loading: fastertransformer:1<br>fauxpilot-triton-1         | I0803 01:51:02.936798 93 libfastertransformer.cc:1226] TRITONBACKEND_Initialize: fastertransformer<br>fauxpilot-triton-1         | I0803 01:51:02.936818 93 libfastertransformer.cc:1236] Triton TRITONBACKEND API version: 1.10<br>fauxpilot-triton-1         | I0803 01:51:02.936821 93 libfastertransformer.cc:1242] <span class="hljs-string">&#x27;fastertransformer&#x27;</span> TRITONBACKEND API version: 1.10<br>fauxpilot-triton-1         | I0803 01:51:02.936850 93 libfastertransformer.cc:1274] TRITONBACKEND_ModelInitialize: fastertransformer (version 1)<br>fauxpilot-triton-1         | W0803 01:51:02.937855 93 libfastertransformer.cc:149] model configuration:<br>fauxpilot-triton-1         | &#123;<br>[... lots more output trimmed ...]<br>fauxpilot-triton-1         | I0803 01:51:04.711929 93 libfastertransformer.cc:321] After Loading Model:<br>fauxpilot-triton-1         | I0803 01:51:04.712427 93 libfastertransformer.cc:537] Model instance is created on GPU NVIDIA RTX A6000<br>fauxpilot-triton-1         | I0803 01:51:04.712694 93 model_repository_manager.cc:1345] successfully loaded <span class="hljs-string">&#x27;fastertransformer&#x27;</span> version 1<br>fauxpilot-triton-1         | I0803 01:51:04.712841 93 server.cc:556] <br>fauxpilot-triton-1         | +------------------+------+<br>fauxpilot-triton-1         | | Repository Agent | Path |<br>fauxpilot-triton-1         | +------------------+------+<br>fauxpilot-triton-1         | +------------------+------+<br>fauxpilot-triton-1         | <br>fauxpilot-triton-1         | I0803 01:51:04.712916 93 server.cc:583] <br>fauxpilot-triton-1         | +-------------------+-----------------------------------------------------------------------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------+<br>fauxpilot-triton-1         | | Backend           | Path                                                                        | Config                                                                                                                                                         |<br>fauxpilot-triton-1         | +-------------------+-----------------------------------------------------------------------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------+<br>fauxpilot-triton-1         | | fastertransformer | /opt/tritonserver/backends/fastertransformer/libtriton_fastertransformer.so | &#123;<span class="hljs-string">&quot;cmdline&quot;</span>:&#123;<span class="hljs-string">&quot;auto-complete-config&quot;</span>:<span class="hljs-string">&quot;false&quot;</span>,<span class="hljs-string">&quot;min-compute-capability&quot;</span>:<span class="hljs-string">&quot;6.000000&quot;</span>,<span class="hljs-string">&quot;backend-directory&quot;</span>:<span class="hljs-string">&quot;/opt/tritonserver/backends&quot;</span>,<span class="hljs-string">&quot;default-max-batch-size&quot;</span>:<span class="hljs-string">&quot;4&quot;</span>&#125;&#125; |<br>fauxpilot-triton-1         | +-------------------+-----------------------------------------------------------------------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------+<br>fauxpilot-triton-1         | <br>fauxpilot-triton-1         | I0803 01:51:04.712959 93 server.cc:626] <br>fauxpilot-triton-1         | +-------------------+---------+--------+<br>fauxpilot-triton-1         | | Model             | Version | Status |<br>fauxpilot-triton-1         | +-------------------+---------+--------+<br>fauxpilot-triton-1         | | fastertransformer | 1       | READY  |<br>fauxpilot-triton-1         | +-------------------+---------+--------+<br>fauxpilot-triton-1         | <br>fauxpilot-triton-1         | I0803 01:51:04.738989 93 metrics.cc:650] Collecting metrics <span class="hljs-keyword">for</span> GPU 0: NVIDIA RTX A6000<br>fauxpilot-triton-1         | I0803 01:51:04.739373 93 tritonserver.cc:2159] <br>fauxpilot-triton-1         | +----------------------------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+<br>fauxpilot-triton-1         | | Option                           | Value                                                                                                                                                                                        |<br>fauxpilot-triton-1         | +----------------------------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+<br>fauxpilot-triton-1         | | server_id                        | triton                                                                                                                                                                                       |<br>fauxpilot-triton-1         | | server_version                   | 2.23.0                                                                                                                                                                                       |<br>fauxpilot-triton-1         | | server_extensions                | classification sequence model_repository model_repository(unload_dependents) schedule_policy model_configuration system_shared_memory cuda_shared_memory binary_tensor_data statistics trace |<br>fauxpilot-triton-1         | | model_repository_path[0]         | /model                                                                                                                                                                                       |<br>fauxpilot-triton-1         | | model_control_mode               | MODE_NONE                                                                                                                                                                                    |<br>fauxpilot-triton-1         | | strict_model_config              | 1                                                                                                                                                                                            |<br>fauxpilot-triton-1         | | rate_limit                       | OFF                                                                                                                                                                                          |<br>fauxpilot-triton-1         | | pinned_memory_pool_byte_size     | 268435456                                                                                                                                                                                    |<br>fauxpilot-triton-1         | | cuda_memory_pool_byte_size&#123;0&#125;    | 67108864                                                                                                                                                                                     |<br>fauxpilot-triton-1         | | response_cache_byte_size         | 0                                                                                                                                                                                            |<br>fauxpilot-triton-1         | | min_supported_compute_capability | 6.0                                                                                                                                                                                          |<br>fauxpilot-triton-1         | | strict_readiness                 | 1                                                                                                                                                                                            |<br>fauxpilot-triton-1         | | exit_timeout                     | 30                                                                                                                                                                                           |<br>fauxpilot-triton-1         | +----------------------------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+<br>fauxpilot-triton-1         | <br>fauxpilot-triton-1         | I0803 01:51:04.740423 93 grpc_server.cc:4587] Started GRPCInferenceService at 0.0.0.0:8001<br>fauxpilot-triton-1         | I0803 01:51:04.740608 93 http_server.cc:3303] Started HTTPService at 0.0.0.0:8000<br>fauxpilot-triton-1         | I0803 01:51:04.781561 93 http_server.cc:178] Started Metrics Service at 0.0.0.0:8002<br></code></pre></td></tr></table></figure><p>运行成功后最后会有服务开启的提示。</p></li><li><p>创建交互API</p></li></ol><p>这里需要安装openai的包。</p><figure class="highlight ipython"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs ipython">$ ipython<br>Python <span class="hljs-number">3.8</span><span class="hljs-number">.10</span> (default, Mar <span class="hljs-number">15</span> <span class="hljs-number">2022</span>, <span class="hljs-number">12</span>:<span class="hljs-number">22</span>:08) <br><span class="hljs-type">Type</span> <span class="hljs-string">&#x27;copyright&#x27;</span>, <span class="hljs-string">&#x27;credits&#x27;</span> <span class="hljs-keyword">or</span> <span class="hljs-string">&#x27;license&#x27;</span> <span class="hljs-keyword">for</span> more information<br>IPython <span class="hljs-number">8.2</span><span class="hljs-number">.0</span> -- An enhanced Interactive Python. <span class="hljs-type">Type</span> <span class="hljs-string">&#x27;?&#x27;</span> <span class="hljs-keyword">for</span> <span class="hljs-built_in">help</span>.<br><br>In [<span class="hljs-number">1</span>]: <span class="hljs-keyword">import</span> openai<br><br>In [<span class="hljs-number">2</span>]: openai.api_key = <span class="hljs-string">&#x27;dummy&#x27;</span><br><br>In [<span class="hljs-number">3</span>]: openai.api_base = <span class="hljs-string">&#x27;http://127.0.0.1:5000/v1&#x27;</span><br><br>In [<span class="hljs-number">4</span>]: result = openai.Completion.create(engine=<span class="hljs-string">&#x27;codegen&#x27;</span>, prompt=<span class="hljs-string">&#x27;def hello&#x27;</span>, max_tokens=<span class="hljs-number">16</span>, temperature=<span class="hljs-number">0.1</span>, stop=[<span class="hljs-string">&quot;\n\n&quot;</span>])<br><br>In [<span class="hljs-number">5</span>]: result<br>Out[<span class="hljs-number">5</span>]: <br>&lt;OpenAIObject text_completion <span class="hljs-built_in">id</span>=cmpl-6hqu8Rcaq25078IHNJNVooU4xLY6w at <span class="hljs-number">0x7f602c3d2f40</span>&gt; JSON: &#123;<br>  <span class="hljs-string">&quot;choices&quot;</span>: [<br>    &#123;<br>      <span class="hljs-string">&quot;finish_reason&quot;</span>: <span class="hljs-string">&quot;stop&quot;</span>,<br>      <span class="hljs-string">&quot;index&quot;</span>: <span class="hljs-number">0</span>,<br>      <span class="hljs-string">&quot;logprobs&quot;</span>: null,<br>      <span class="hljs-string">&quot;text&quot;</span>: <span class="hljs-string">&quot;() &#123;\n    return \&quot;Hello, World!\&quot;;\n&#125;&quot;</span><br>    &#125;<br>  ],<br>  <span class="hljs-string">&quot;created&quot;</span>: <span class="hljs-number">1659492191</span>,<br>  <span class="hljs-string">&quot;id&quot;</span>: <span class="hljs-string">&quot;cmpl-6hqu8Rcaq25078IHNJNVooU4xLY6w&quot;</span>,<br>  <span class="hljs-string">&quot;model&quot;</span>: <span class="hljs-string">&quot;codegen&quot;</span>,<br>  <span class="hljs-string">&quot;object&quot;</span>: <span class="hljs-string">&quot;text_completion&quot;</span>,<br>  <span class="hljs-string">&quot;usage&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;completion_tokens&quot;</span>: <span class="hljs-number">15</span>,<br>    <span class="hljs-string">&quot;prompt_tokens&quot;</span>: <span class="hljs-number">2</span>,<br>    <span class="hljs-string">&quot;total_tokens&quot;</span>: <span class="hljs-number">17</span><br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><ol start="4"><li>配置copilot插件<br>修改vscode配置文件，在全局或者项目中打开 <code>setting.json</code>，编辑如下内容即可：</li></ol><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json">&quot;github.copilot.advanced&quot;: &#123;<br>    &quot;debug.overrideEngine&quot;: &quot;codegen&quot;,<br>    &quot;debug.testOverrideProxyUrl&quot;: &quot;http://localhost:5000&quot;,<br>    &quot;debug.overrideProxyUrl&quot;: &quot;http://localhost:5000&quot;<br>&#125;<br></code></pre></td></tr></table></figure><p>localhost改成具体的ip地址即可在内网使用。</p>]]></content>
    
    
    <categories>
      
      <category>教程</category>
      
      <category>Docker使用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>copilot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>k8s初探</title>
    <link href="/2022/08/15/k8s%E5%88%9D%E6%8E%A2/"/>
    <url>/2022/08/15/k8s%E5%88%9D%E6%8E%A2/</url>
    
    <content type="html"><![CDATA[<p>看<a href="https://link.jscdn.cn/1drv/aHR0cHM6Ly8xZHJ2Lm1zL2IvcyFBa3A3T0FGTWxmRUtoNWRVS1ZUaWhIMjZsVGxUTXc_ZT03VWlzemw.pdf">《Kubernates in Action》</a>做一点笔记。</p><p><a href="https://minikube.sigs.k8s.io/docs/">minikube文档</a><br><a href="https://kubernetes.io/zh-cn/docs/tutorials/kubernetes-basics/">基于minikube的kubernetes官方教程</a></p><h3 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h3><p>容器技术是一种轻量级的虚拟化技术，在Linux架构中，可以通过命名空间跟用户组构建一个与主机相互隔离，占用指定计算资源的进程。在容器中一般可以不受影响地运行应用程序。<br><img src="https://link.jscdn.cn/1drv/aHR0cHM6Ly8xZHJ2Lm1zL3UvcyFBa3A3T0FGTWxmRUtoNWRjU1ZjMGRRaEhmam1pUmc_ZT16NUJBU3I.png" alt="虚拟机与容器"></p><h3 id="Kubernates-集群架构"><a href="#Kubernates-集群架构" class="headerlink" title="Kubernates 集群架构"></a>Kubernates 集群架构</h3><p>k8s简单来说就是对容器进行统一管理跟调度的软件工具。从架构上分为两部分：</p><p><img src="https://link.jscdn.cn/1drv/aHR0cHM6Ly8xZHJ2Lm1zL3UvcyFBa3A3T0FGTWxmRUtoNWRZbDVFcWU1eEg2LWp3dGc_ZT01MmNwRXA.png" alt="k8s集群架构"></p><h3 id="k8s对容器的管理"><a href="#k8s对容器的管理" class="headerlink" title="k8s对容器的管理"></a>k8s对容器的管理</h3><ol><li>根据应用的描述信息将对应数量的容器或者容器集合</li><li>k8s可以根据负载自动决定一个应用程序的最佳副本数量，自动调整副本数。</li><li>（pod）调度到工作节点上，工作节点上的Kubelets将告知Docker从镜像仓库中拉取容器镜像并且运行容器。</li><li>k8s会不断地确认应用程序的部署状态始终与描述相匹配。如果其中一个进程崩溃，k8s会自动重新部署该进程。如果整个工作节点都死亡或者无法访问，则k8s会在新节点上部署故障节点中运行的所有容器并且运行。</li><li>kube-proxy可以为相同的服务配置一个静态ip地址，这样不管容器如何移动或者增减，都可以通过该ip地址访问该服务。还可以确保服务的链接可以跨提供服务的容器实现负载均衡。</li></ol><h3 id="docker基础命令"><a href="#docker基础命令" class="headerlink" title="docker基础命令"></a>docker基础命令</h3><p>docker使用主要三部分：</p><pre><code class=" mermaid">graph LRA[docker]--&gt;B[docker image]--&gt;C[docker container]</code></pre><p>其中container是最后运行的容器实例，而image是容器本身的镜像文件，通过镜像可以build容器实例。docker本身则是对镜像和容器进行管理。以下是一些命令：</p><ul><li><p>构建容器镜像：<code>docker build -t IMAGE DOCKERFILEPATH</code>，使用DOCKERFILEPATH下的dockerfile文件构建名叫kubia的镜像。</p></li><li><p>显示镜像列表：<code>docker images</code>。</p></li><li><p>删除某一镜像：<code>docker rmi IMAGE</code>。</p></li><li><p>运行容器镜像并绑定端口：<code>docker run --name CONTAINER -p PORT:PORT -d IMAGE</code>。</p></li><li><p>获取容器信息：<code>docker ps</code>，<code>docker inspect CONTAINER</code>会有更详细的信息。</p></li><li><p>运行容器shell：<code>docker exec -it kubia-container bash</code>，前提是镜像本身包含了bash shell，<code>-i</code>保证标准输入流开放，<code>-t</code>分配一个伪终端，两个选项在一起才能正常运行bash。</p></li><li><p>开启/重启容器：<code>docker start CONTAINER</code>/<code>docker restart CONTAINER</code>。</p></li><li><p>停止容器：<code>docker stop CONTAINER</code>。</p></li><li><p>删除容器: <code>docker rm CONTAINER</code>。</p></li><li><p>为镜像添加标签：<code>docker tag IMAGE NEWTAG</code>，标签即为镜像的别名。</p></li><li><p>推送镜像到docker hub：<code>docker push TAG</code>。</p></li></ul><h3 id="安装Minikube"><a href="#安装Minikube" class="headerlink" title="安装Minikube"></a>安装Minikube</h3><p>minikube是用于构建本地单节点集群的工具，主要用于测试k8s和本地开发应用。配置多节点或者云平台生产环境需要使用更多的k8s集群需要参考<a href="https://kubernetes.io/">https://kubernetes.io/</a>。</p><p>最新版本的minikube集成了kvm/virtualbox的底座，所以不需要额外安装vm。</p><p>下载并安装最新版本的minikube：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -LO https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64 &amp;&amp; chmod +x minikube<br>sudo mkdir -p /usr/<span class="hljs-built_in">local</span>/bin/ <br>sudo install minikube /usr/<span class="hljs-built_in">local</span>/bin/<br></code></pre></td></tr></table></figure><p>然后运行<code>minikube start --kubernetes-version=1.23.8</code>，最新版本的kubernetes会报错，所以这里最好指定kubernetes的镜像版本。如果提示docker版本过低请自行重装一下最新版本的docker。 运行成功会出现：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">* Done! kubectl is now configured to use &quot;minikube&quot; cluster and &quot;default&quot; namespace by d<br></code></pre></td></tr></table></figure><p>要与kubernetes进行交互，还需要kubectl，注意需要安装对应版本的kubectl，否则会出现兼容性问题。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -LO https://dl.k8s.io/release/v1.23.8/bin/linux/amd64/kubectl<br>sudo install -o root -g root -m 0755 kubectl /usr/<span class="hljs-built_in">local</span>/bin/kubectl<br></code></pre></td></tr></table></figure><p>然后运行<code>kubectl version</code>，会出现client与server的版本信息。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">Client Version: version.Info&#123;Major:&quot;1&quot;, Minor:&quot;23&quot;, GitVersion:&quot;v1.23.8&quot;, GitCommit:&quot;a12b886b1da059e0190c54d09c5eab5219dd7acf&quot;, GitTreeState:&quot;clean&quot;, BuildDate:&quot;2022-06-16T05:57:43Z&quot;, GoVersion:&quot;go1.17.11&quot;, Compiler:&quot;gc&quot;, Platform:&quot;linux/amd64&quot;&#125;<br>Server Version: version.Info&#123;Major:&quot;1&quot;, Minor:&quot;23&quot;, GitVersion:&quot;v1.23.8&quot;, GitCommit:&quot;a12b886b1da059e0190c54d09c5eab5219dd7acf&quot;, GitTreeState:&quot;clean&quot;, BuildDate:&quot;2022-06-16T05:51:36Z&quot;, GoVersion:&quot;go1.17.11&quot;, Compiler:&quot;gc&quot;, Platform:&quot;linux/amd64&quot;&#125;<br></code></pre></td></tr></table></figure><p>运行<code>kubectl cluster-info</code>查看集群信息。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">Kubernetes control plane is running at https://192.168.49.2:8443<br>CoreDNS is running at https://192.168.49.2:8443/api/v1/namespaces/kube-system/services/kube-dns:dns/proxy<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>教程</category>
      
      <category>分布式计算</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>kubernates</tag>
      
      <tag>k8s</tag>
      
      <tag>docker</tag>
      
      <tag>容器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python的使用索引</title>
    <link href="/2022/07/27/python%E7%9A%84%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95/"/>
    <url>/2022/07/27/python%E7%9A%84%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95/</url>
    
    <content type="html"><![CDATA[<p>Python的高级用法尤其是multiprocessing看了很久还是不会用，所以同样开个索引贴记录下。</p><ul><li><a href="https://blog.csdn.net/NasonYehfm/article/details/90167811">Python ABC(抽象基类)</a></li><li><a href="python%E7%9A%84@abstractmethod">python的@abstractmethod</a></li><li><a href="http://c.biancheng.net/view/4561.html">@property装饰器</a></li><li><a href="https://pypi.org/project/cloudpickle/">cloudpickle</a></li><li><a href="https://docs.python.org/zh-cn/3/library/multiprocessing.html#contexts-and-start-methods">multiprocessing库文档</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>教程</category>
      
      <category>python使用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>torch的使用索引</title>
    <link href="/2022/07/26/torch%E7%9A%84%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95/"/>
    <url>/2022/07/26/torch%E7%9A%84%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95/</url>
    
    <content type="html"><![CDATA[<p>新开一篇文章，记录一些博客文章索引或者笔记。暂时还没有细致地读文档的需求，所以看看博客解决问题。</p><ul><li><a href="https://blog.csdn.net/hfut_lf/article/details/122156232">torch 单机多卡运行</a></li><li><code>torch.set_num_threads</code>设置多线程时占用的线程数，300%即为使用三个核心。</li></ul>]]></content>
    
    
    <categories>
      
      <category>教程</category>
      
      <category>pytorch使用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RL</tag>
      
      <tag>ML</tag>
      
      <tag>pytorch</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MAPPO的实现细节(一)</title>
    <link href="/2022/07/20/MAPPO%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82(%E4%B8%80)/"/>
    <url>/2022/07/20/MAPPO%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82(%E4%B8%80)/</url>
    
    <content type="html"><![CDATA[<p>之前研读过light-mappo的代码，对于其中强化学习的部分已经有所了解，想要自己跑一下但是环境的部分被抽走了，所以还是看看原版的代码并做点笔记。</p><p>先介绍一下MAPPO，原文<a href="https://arxiv.org/abs/2103.01955">The Surprising Effectiveness of PPO in Cooperative, Multi-Agent Games</a>，主要解决的问题是，将PPO算法应用在Multi-Agent环境中需要使用的一些技巧，从IPPO扩展到MAPPO。项目地址：<a href="https://github.com/marlbenchmark/on-policy">MAPPO</a>。</p><h3 id="MAPPO的环境配置"><a href="#MAPPO的环境配置" class="headerlink" title="MAPPO的环境配置"></a>MAPPO的环境配置</h3><p>这个项目的第一个难点就是环境配置。项目提供了requirements.txt，使用 <code>pip install -r requirements.txt</code>安装对应的环境。也提供了environment.yaml,  使用 <code>conda env create -f environment.yaml</code> 命令安装对于的环境。但是由于本项目使用的python 3.6不再维护，很多包的版本也已经过期，所以使用上述命令并不能使得项目能够运行。使用 <code>conda create -n py37 python=3.7</code>命令创建环境。然后建议使用 <code>pip install -r requirements.txt</code>。使用 <code>pip freeze &gt; requirements.txt</code>命令生成。我使用的是<a href="https://link.jscdn.cn/1drv/aHR0cHM6Ly8xZHJ2Lm1zL3QvcyFBa3A3T0FGTWxmRUtodkpTY3BsYjJfMVFkZzZkYnc_ZT1FZDduckM.txt">requirements.txt</a>, 由于使用的CUDA环境不一样，pytorch请自行安装</p><p>项目使用了wandb作为训练logger，关于wandb的使用参见，<a href="https://zhuanlan.zhihu.com/p/493093033">wandb使用教程(一)：基础用法</a>。</p><p>在scripts文件夹中给出了很多运行的脚本，但是sh脚本对我来说始终有编码的问题，而python本身就是脚本语言，所以我直接在py文件中添加参数，当然也可以使用命令行运行，我觉得要比sh脚本方便很多。</p><p>我选择了足球作为应用的环境，本项目使用了谷歌足球的环境，参见<a href="https://github.com/google-research/football/blob/master/README.md">gfootball</a>, 按照说明按照对应的依赖与环境。将train_football.py放到根目录，然后按照sh文件修改对应的参数，使用wandb需要将对应的用户名改成自己的用户名。</p><p>至此应该是能够顺利运行本项目了。下图是我的训练结果，好像不太行。<img src="https://link.jscdn.cn/1drv/aHR0cHM6Ly8xZHJ2Lm1zL3UvcyFBa3A3T0FGTWxmRUtodlFxYlZwaWJSNHg3U0htaVE_ZT1ISFNYQTY.png" alt="足球环境训练结果"></p><h3 id="多线程Env"><a href="#多线程Env" class="headerlink" title="多线程Env"></a>多线程Env</h3><p>能够运行之后，在train_football.py中的第一步是创建Env。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">make_train_env</span>(<span class="hljs-params">all_args</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_env_fn</span>(<span class="hljs-params">rank</span>):</span><br>        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">init_env</span>():</span><br>            <span class="hljs-keyword">if</span> all_args.env_name == <span class="hljs-string">&quot;Football&quot;</span>:<br>                env = FootballEnv(all_args)<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Can not support the &quot;</span> +<br>                      all_args.env_name + <span class="hljs-string">&quot; environment.&quot;</span>)<br>                <span class="hljs-keyword">raise</span> NotImplementedError<br>            env.seed(all_args.seed + rank * <span class="hljs-number">1000</span>)<br>            <span class="hljs-keyword">return</span> env<br>        <span class="hljs-keyword">return</span> init_env<br>    <span class="hljs-keyword">if</span> all_args.n_rollout_threads == <span class="hljs-number">1</span>:<br>        <span class="hljs-keyword">return</span> DummyVecEnv([get_env_fn(<span class="hljs-number">0</span>)])<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> SubprocVecEnv([get_env_fn(i) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<br>            all_args.n_rollout_threads)])<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">make_eval_env</span>(<span class="hljs-params">all_args</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_env_fn</span>(<span class="hljs-params">rank</span>):</span><br>        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">init_env</span>():</span><br>            <span class="hljs-keyword">if</span> all_args.env_name == <span class="hljs-string">&quot;Football&quot;</span>:<br>                env = FootballEnv(all_args)<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Can not support the &quot;</span> +<br>                      all_args.env_name + <span class="hljs-string">&quot; environment.&quot;</span>)<br>                <span class="hljs-keyword">raise</span> NotImplementedError<br>            env.seed(all_args.seed * <span class="hljs-number">50000</span> + rank * <span class="hljs-number">10000</span>)<br>            <span class="hljs-keyword">return</span> env<br>        <span class="hljs-keyword">return</span> init_env<br>    <span class="hljs-keyword">if</span> all_args.n_eval_rollout_threads == <span class="hljs-number">1</span>:<br>        <span class="hljs-keyword">return</span> DummyVecEnv([get_env_fn(<span class="hljs-number">0</span>)])<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> SubprocVecEnv([get_env_fn(i) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<br>            all_args.n_eval_rollout_threads)])<br><br><span class="hljs-comment"># env init</span><br>envs = make_train_env(all_args)<br>eval_envs = make_eval_env(all_args) <span class="hljs-keyword">if</span> all_args.use_eval <span class="hljs-keyword">else</span> <span class="hljs-literal">None</span><br>num_agents = all_args.num_agents<br></code></pre></td></tr></table></figure><p>为了实现多线程执行，并且统一收取不同运行环境中的数据，使用SubprocVecEnv创建多线程运行环境。 这里传入SubprocvecEnv的参数env_fns是一个函数，这个函数的返回值是一个环境，这个环境的初始化函数是init_env。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SubprocVecEnv</span>(<span class="hljs-params">ShareVecEnv</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, env_fns, spaces=<span class="hljs-literal">None</span></span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        envs: list of gym environments to run in subprocesses</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        self.waiting = <span class="hljs-literal">False</span><br>        self.closed = <span class="hljs-literal">False</span><br>        nenvs = <span class="hljs-built_in">len</span>(env_fns)<br>        self.remotes, self.work_remotes = <span class="hljs-built_in">zip</span>(*[Pipe() <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(nenvs)])<br>        self.ps = [Process(target=worker, args=(work_remote, remote, CloudpickleWrapper(env_fn)))<br>                   <span class="hljs-keyword">for</span> (work_remote, remote, env_fn) <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(self.work_remotes, self.remotes, env_fns)]<br>        <span class="hljs-keyword">for</span> p <span class="hljs-keyword">in</span> self.ps:<br>            p.daemon = <span class="hljs-literal">True</span>  <span class="hljs-comment"># if the main process crashes, we should not cause things to hang </span><br>            p.start()<br>        <span class="hljs-keyword">for</span> remote <span class="hljs-keyword">in</span> self.work_remotes:<br>            remote.close()<br><br>        self.remotes[<span class="hljs-number">0</span>].send((<span class="hljs-string">&#x27;get_spaces&#x27;</span>, <span class="hljs-literal">None</span>))<br>        observation_space, share_observation_space, action_space = self.remotes[<span class="hljs-number">0</span>].recv()<br>        ShareVecEnv.__init__(self, <span class="hljs-built_in">len</span>(env_fns), observation_space,<br>                             share_observation_space, action_space)<br></code></pre></td></tr></table></figure><p>首先是创建每个进程的通信管道，<code>multiprocessing.Pipe()</code>提供了一个管道，可以用来进行进程间的通信。然后将通信进程绑定到worker当中，创建不同的进程。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">worker</span>(<span class="hljs-params">remote, parent_remote, env_fn_wrapper</span>):</span><br>    <span class="hljs-comment"># 指示当前进程将不会再往队列中放入对象。双工的通信管道当成单工使用</span><br>    parent_remote.close()<br>    env = env_fn_wrapper.x()<br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        cmd, data = remote.recv()<br>        <span class="hljs-keyword">if</span> cmd == <span class="hljs-string">&#x27;step&#x27;</span>:<br>            ob, reward, done, info = env.step(data)<br>            <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;bool&#x27;</span> <span class="hljs-keyword">in</span> done.__class__.__name__:<br>                <span class="hljs-keyword">if</span> done:<br>                    ob = env.reset()<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">if</span> np.<span class="hljs-built_in">all</span>(done):<br>                    ob = env.reset()<br><br>            remote.send((ob, reward, done, info))<br>        <span class="hljs-keyword">elif</span> cmd == <span class="hljs-string">&#x27;reset&#x27;</span>:<br>            ob = env.reset()<br>            remote.send((ob))<br>        <span class="hljs-keyword">elif</span> cmd == <span class="hljs-string">&#x27;render&#x27;</span>:<br>            <span class="hljs-keyword">if</span> data == <span class="hljs-string">&quot;rgb_array&quot;</span>:<br>                fr = env.render(mode=data)<br>                remote.send(fr)<br>            <span class="hljs-keyword">elif</span> data == <span class="hljs-string">&quot;human&quot;</span>:<br>                env.render(mode=data)<br>        <span class="hljs-keyword">elif</span> cmd == <span class="hljs-string">&#x27;reset_task&#x27;</span>:<br>            ob = env.reset_task()<br>            remote.send(ob)<br>        <span class="hljs-keyword">elif</span> cmd == <span class="hljs-string">&#x27;close&#x27;</span>:<br>            env.close()<br>            remote.close()<br>            <span class="hljs-keyword">break</span><br>        <span class="hljs-keyword">elif</span> cmd == <span class="hljs-string">&#x27;get_spaces&#x27;</span>:<br>            remote.send((env.observation_space, env.share_observation_space, env.action_space))<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">raise</span> NotImplementedError<br></code></pre></td></tr></table></figure><p>然后在每个worker进程中，使用env_fn_wrapper.x()来创建环境，然后使用remote.recv()来接收命令，然后使用<code>remote.send()</code>来发送数据。在worker中的worker_remote相应地发送进程数据。其中这里足球环境返回的数据是ob, reward, done, info。</p><p>通过这种方式，实现了多进程环境的创建、初始化与通信。然后使用<code>step()</code>方法收取不同进程产生的训练数据。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SubprocVecEnv</span>(<span class="hljs-params">ShareVecEnv</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">step_async</span>(<span class="hljs-params">self, actions</span>):</span><br>        <span class="hljs-keyword">for</span> remote, action <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(self.remotes, actions):<br>            remote.send((<span class="hljs-string">&#x27;step&#x27;</span>, action))<br>        self.waiting = <span class="hljs-literal">True</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">step_wait</span>(<span class="hljs-params">self</span>):</span><br>        results = [remote.recv() <span class="hljs-keyword">for</span> remote <span class="hljs-keyword">in</span> self.remotes]<br>        self.waiting = <span class="hljs-literal">False</span><br>        obs, rews, dones, infos = <span class="hljs-built_in">zip</span>(*results)<br>        <span class="hljs-keyword">return</span> np.stack(obs), np.stack(rews), np.stack(dones), infos<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">step</span>(<span class="hljs-params">self, actions</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        Step the environments synchronously.</span><br><span class="hljs-string"></span><br><span class="hljs-string">        This is available for backwards compatibility.</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        self.step_async(actions)<br>        <span class="hljs-keyword">return</span> self.step_wait()<br></code></pre></td></tr></table></figure><p>关于多线程Env的总结，从流程上，对google football这个环境进行了三层封装，一层是将football封装成FootballEnv，在这之中可以配置reward，以及render方法，第二层是把这个环境塞进worker并且配置通信进程，第三层是将多线程worker封装成一个新的SubprocVecEnv，并且统一进行step, reset, close等操作。</p><pre><code class=" mermaid">classDiagramclass SubprocVecEnvSubprocVecEnv: psSubprocVecEnv: step()class psps: workerps: remoteps: remote.recv()ps: remote.send()SubprocVecEnv &lt;-- psclass workerworker: FootballEnvps &lt;-- worker</code></pre>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>强化学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RL</tag>
      
      <tag>MARL</tag>
      
      <tag>MAPPO</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>复制博客园或者CSDN文章</title>
    <link href="/2022/07/19/%E5%A4%8D%E5%88%B6%E5%8D%9A%E5%AE%A2%E5%9B%AD%E6%88%96%E8%80%85CSDN%E6%96%87%E7%AB%A0/"/>
    <url>/2022/07/19/%E5%A4%8D%E5%88%B6%E5%8D%9A%E5%AE%A2%E5%9B%AD%E6%88%96%E8%80%85CSDN%E6%96%87%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<p>在转载博客的时候，出于对于站点的不信任，还是倾向于将对应的博文保存到本地。</p><p>参考了如下方法，可以直接提取CSDN或者博客园中的博文内容，并将html直接粘贴到markdown中，实现复制博文的效果，其他站点应该也类似，不过显然图床的问题也并没有解决，会随时挂掉。</p><p>以下内容为直接粘贴html元素：</p><hr><div id="article_content" class="article_content clearfix">        <link rel="stylesheet" href="https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/ck_htmledit_views-bbac9290cd.css">                <div id="content_views" class="markdown_views prism-atom-one-dark">                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>                    </svg>                    <p><strong>复制csdn或者博客园文章时，图片无法直接粘贴过来解决办法。</strong></p> <p>1、csdn 文章页面，打开浏览器开发者工具</p> <p>2、找到文章正文对应的 html 元素，按ctrl+f输入标签头关键字 （含 "article_content"标签头(csdn文章) ，如果是博客园文章，则标签头是“cnblogs_post_body”）</p> <p><img src="https://img-blog.csdnimg.cn/img_convert/264838c821805a1acf1fdd5cc54e7268.png" alt="img"></p> <p>3、在该元素源代码上右键 “Copy”->“Copy element”</p> <p><img src="https://img-blog.csdnimg.cn/img_convert/bd91c1b2f1b0994e12545d15ad1d7dc9.png" alt="img"></p> <p>4、新建一个 txt 文件，将后缀改为 .html ，把刚复制的 源代码 粘贴到文件中，浏览器打开，此时复制全文，到博客园 添加新随笔，粘贴。<br> 5、或者复制全文到markdown，到cadn 添加新随笔导入markdown。</p> <blockquote>  <p>解决方法参考：https://jingyan.baidu.com/article/0964eca24e159c8285f53618.html</p> </blockquote>                </div><div><div></div></div>                <link href="https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-3fd7f7a902.css" rel="stylesheet">                <link href="https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-49037e4d27.css" rel="stylesheet">        </div>]]></content>
    
    
    <categories>
      
      <category>教程</category>
      
      <category>博客设置</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网页</tag>
      
      <tag>博客</tag>
      
      <tag>blog</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ffmpeg使用(未完)</title>
    <link href="/2022/07/18/ffmpeg%E4%BD%BF%E7%94%A8/"/>
    <url>/2022/07/18/ffmpeg%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>一直想建立一个视频搬运的工作流，比如在b站上看到什么视频了，复制下链接，然后自动抓取转码和上传到推特或者油管，推特机器人账号需要自己有服务器，所以再议。<br>本文主要是收集一些ffmpeg的使用，视频剪辑软件对于我的需求来说太重了。比如我可能需要的是剪切，转码，音频提取（接翻译接口），字幕生成之类的，这些事情脚本做还是比较方便的。<br>然后因为还是参考别人的博客也没有自己读文档，先在这里记录一下地址。</p><h3 id="转码"><a href="#转码" class="headerlink" title="转码"></a>转码</h3><hr><div id="article_content" class="article_content clearfix">        <link rel="stylesheet" href="https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/ck_htmledit_views-bbac9290cd.css">                <div id="content_views" class="htmledit_views">                    <h1><a name="t0"></a>1. 准备</h1> <h3><a name="t1"></a>1.1 下载<a href="https://so.csdn.net/so/search?q=ffmpeg&spm=1001.2101.3001.7020" target="_blank" class="hl hl-1" data-report-click="{"spm":"1001.2101.3001.7020","dest":"https://so.csdn.net/so/search?q=ffmpeg&spm=1001.2101.3001.7020"}" data-tit="ffmpeg" data-pretit="ffmpeg">ffmpeg</a></h3> <p>进入ffmpeg官网<a href="https://www.ffmpeg.org/download.html" title="Download FFmpeg">Download FFmpeg</a>，根据自己的系统下载相应封装，这里以Windows为例。</p> <p style="text-align:center;"><img alt="" src="https://img-blog.csdnimg.cn/8cae5f53974c47e1a5dbe7f09e85c638.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IuP5pmTa8SBb-mUruebmA==,size_20,color_FFFFFF,t_70,g_se,x_16"></p> <p>选择篮框中任意一项进行下载。</p> <p style="text-align:center;">以下是选择第一项后的截图<img alt="" src="https://img-blog.csdnimg.cn/bc35a21c4c3d4d3c9c15ec70674ca02d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IuP5pmTa8SBb-mUruebmA==,size_20,color_FFFFFF,t_70,g_se,x_16"> </p> <p>下载合适的release，解压，将bin目录下的exe文件全部复制到目录<span style="color:#38d8f0;">C:\Windows\System32</span>下。</p> <h3><a name="t2"></a>1.2 cmd基础</h3> <p><strong>1.2.1 打开cmd</strong></p> <p>通过win+R，或 右键“开始”选择“运行”可进入cmd。</p> <p><strong>1.2.2 进入指定文件夹</strong></p> <p>①进入某个磁盘，直接盘符代号：如D：，然后回车，到D盘下（不用CD 命令切换）</p> <p>②输入dir，可以看到d盘下的各个文件名称</p> <p>③进入除根录以外的文件夹 ：  cd  文件夹路径（cd  xxx\xxx\xxx）回车</p> <p>④进入上一层目录 ： cd ../</p> <p>⑤返回D盘：cd\  </p> <p>⑥返回C盘：直接输入c: ，回车</p> <p>注： 不能在一打开cmd的时候运行cd  d:\xxx\xxx，需要先进入磁盘</p> <p>以进入<span style="color:#38d8f0;">E:\Videos\S</span>为例。</p> <p>在cmd中输入磁盘符<span style="color:#38d8f0;">E：</span><span style="color:#0d0016;">，回车。这一步不用cd命令。</span></p> <p><span style="color:#0d0016;">然后输入</span><span style="color:#38d8f0;">cd Videos\S</span><span style="color:#0d0016;">，回车即可。</span></p> <h1><a name="t3"></a>2. 文件转换</h1> <h3><a name="t4"></a>2.1 单个文件</h3> <pre data-index="0"><code class="hljs language-sql">ffmpeg <span class="hljs-operator">-</span>i "input.flv" <span class="hljs-operator">-</span>c <span class="hljs-keyword">copy</span> "output.mp4"</code><div class="hljs-button {2}" data-title="复制" onclick="hljs.copyCode(event)"></div></pre> <p>将这里的input改为你的文件名，output改为你想得到的文件名即可。</p> <h3><a name="t5"></a>2.2 批量转换</h3> <pre data-index="1"><code class="hljs language-perl"><span class="hljs-keyword">for</span> %i in (*.flv) <span class="hljs-keyword">do</span> ffmpeg -i <span class="hljs-string">"%i"</span> -c copy <span class="hljs-string">"%~ni.mp4"</span></code><div class="hljs-button {2}" data-title="复制" onclick="hljs.copyCode(event)"></div></pre> <p>这时新生成的mp4文件会沿用原文件名。</p> <h3><a name="t6"></a>2.3 某些flv文件转换成mp4时会报错，这时可尝试以下代码：</h3> <pre data-index="2"><code class="hljs language-r">ffmpeg <span class="hljs-operator">-</span>i filename.flv <span class="hljs-operator">-</span><span class="hljs-built_in">c</span><span class="hljs-operator">:</span>v libx264 <span class="hljs-operator">-</span>crf <span class="hljs-number">19</span> <span class="hljs-operator">-</span>strict experimental filename.mp4</code><div class="hljs-button {2}" data-title="复制" onclick="hljs.copyCode(event)"></div></pre> <p>第一个filename改为需要转换的文件名，第二个filename改为相应的输出文件名。</p> <h3><a name="t7"></a>*2.4 flv/mp4文件的合并</h3> <p>有时通过某些下载工具得到的flv/mp4文件被分为多个片段，但我们希望将它们合并。</p> <p>以合并5个mp4文件：</p> <p>文件1.mp4<br> 文件2.mp4<br> 文件3.mp4<br> 文件4.mp4<br> 文件5.mp4</p> <p>为例。</p> <p>新建一个txt文件，把需要合并的mp4文件的文件名依序写在txt文件中并保存，格式如下：</p> <pre data-index="3"><code class="hljs language-javascript"><ol class="hljs-ln" style="width:100%"><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">file <span class="hljs-string">'文件1.mp4'</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">file <span class="hljs-string">'文件2.mp4'</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">file <span class="hljs-string">'文件3.mp4'</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">file <span class="hljs-string">'文件4.mp4'</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="5"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">file <span class="hljs-string">'文件5.mp4'</span></div></div></li></ol></code><div class="hljs-button {2}" data-title="复制" onclick="hljs.copyCode(event)"></div></pre> <p>注：这里txt文件被命名为<span style="color:#38d8f0;"><strong>combine.txt</strong></span></p> <p>把上述需要合并的mp4文件和这个txt文件放在同一个文件夹下，然后在cmd中进入该文件夹，再输入以下命令：</p> <pre data-index="4"><code class="hljs language-lua">ffmpeg -f <span class="hljs-built_in">concat</span> -safe <span class="hljs-number">0</span> -i combine.txt -c copy <span class="hljs-built_in">output</span>.mp4</code><div class="hljs-button {2}" data-title="复制" onclick="hljs.copyCode(event)"></div></pre> <p>回车。即可得到一个完整的mp4文件。</p> <p>合并多个flv文件的方法类似。</p> <p></p> <p>输出的文件与原文件在同一文件夹中。</p>                </div><div><div></div></div>        </div><hr>]]></content>
    
    
    <categories>
      
      <category>教程</category>
      
      <category>视频编辑</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ffmpeg</tag>
      
      <tag>视频</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python编译so和pyd文件</title>
    <link href="/2022/07/18/python%E7%BC%96%E8%AF%91so%E5%92%8Cpyd%E6%96%87%E4%BB%B6/"/>
    <url>/2022/07/18/python%E7%BC%96%E8%AF%91so%E5%92%8Cpyd%E6%96%87%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<p>python代码即便是编译成pyc也同样可以被反编译，通常为了产品发布跟代码保护，会编译成so(linux)或者pyd(windows)。</p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>主要流程是，先调用Cython包将python代码编译成c代码，再将c代码编译成so文件跟pyd文件。由于使用了gcc，所以需要安装对应的build工具。在windows平台可以通过Visual Studio Installer安装对应的包。</p><p><img src="https://by3302files.storage.live.com/y4mjOIpaxoglVNQtOuyJU2tGo30SMw22C61fR1HgyecUZf0la_8_eL8U8OKQzzNEggffhOxJa6SBBgy1YHwVjIFxzJJW6R1_d2N31XVSWR5BQPmwT7rwHN5hEHfuJ0G2FzDMTOB64tHaNuhqKKu1P_m3qayydJIqX-5TD4Ndr2jFtIrm85rxeL1xYuxo6Rid2si?width=1278&height=686&cropmode=none" alt="Visual Studio Installer 配置C环境"></p><p>Linux 需要自行配置下c++生成工具。</p><h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><p>参考git项目<a href="https://github.com/HamzaAissaoui/PythonCompilerC">PythonCompilerC</a>，一大部分工作在于对目录结构的处理，而这个项目本身生成的so/pyd文件全部在对应的build_path下，原有的目录结构消失。并且，由于不同平台的命令行格式不一样，导致编译的时候出了很多bug。对此做了一些修改，具体项目参见<a href="https://github.com/Coldison/PythonCompile2So">PythonCompileSo</a>。</p><p>将本项目放到要编译的项目的目录下。注意项目中的<strong>init</strong>.py文件需要删掉，这部分编译会出现字符错误。</p><p>Windows平台：</p><figure class="highlight cmd"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cmd">python PROJECTPATH\scripts\compile.py --project-<span class="hljs-built_in">dir</span> PROJECTPATH --build-lib BUILDPATH<br></code></pre></div></td></tr></table></figure><p>Linux平台：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">python PROJECTPATH/scripts/compile.py --project-dir PROJECTPATH --build-lib BUILDPATH<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>教程</category>
      
      <category>python使用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>编译</tag>
      
      <tag>so</tag>
      
      <tag>pyd</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ArgParser的使用</title>
    <link href="/2022/07/13/ArgParser%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2022/07/13/ArgParser%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>命令行运行Python文件时，可以添加相应的参数。如：</p><figure class="highlight vim"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs vim"><span class="hljs-keyword">python</span> <span class="hljs-built_in">add</span>.<span class="hljs-keyword">py</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span><br></code></pre></div></td></tr></table></figure><p>在运行时，<code>from sys import argv</code>就可以读取命令行参数，通常是一个列表，此处的 <code>argv = [add.py, 1, 2]</code>。对于比较复杂的程序，使用这种方式读取命令行参数显然还是比较麻烦的。于是就引入了 <code>argparse</code>模块。具体可以参考官方文档：<a href="https://docs.python.org/3/library/argparse.html" title="argparse官方文档">Parser for command-line options, arguments and sub-commands</a></p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> argparse<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">parse_args</span>():</span><br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    :return:进行参数的解析</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    description = <span class="hljs-string">&quot;you should add those parameter&quot;</span>                   <span class="hljs-comment"># 步骤二</span><br>    parser = argparse.ArgumentParser(description=description)        <span class="hljs-comment"># 这些参数都有默认值，当调用parser.print_help()或者运行程序时由于参数不正确(此时python解释器其实也是调用了pring_help()方法)时，</span><br>                                                                     <span class="hljs-comment"># 会打印这些描述信息，一般只需要传递description参数，如上。</span><br>  <br>    parser.add_argument(<span class="hljs-string">&quot;-rp&quot;</span>, <span class="hljs-string">&quot;--replay_name&quot;</span>, default=<span class="hljs-string">&quot;test.zip&quot;</span>,<span class="hljs-built_in">type</span>=<span class="hljs-built_in">str</span>, <span class="hljs-built_in">help</span>=<span class="hljs-string">&quot;复盘名称&quot;</span>)<br>    parser.add_argument(<span class="hljs-string">&quot;-rv&quot;</span>, <span class="hljs-string">&quot;--redview_on&quot;</span>, action=<span class="hljs-string">&quot;store_true&quot;</span>, default=<span class="hljs-literal">False</span>, <span class="hljs-built_in">help</span>=<span class="hljs-string">&quot;是否是红方视角&quot;</span>)<br>    parser.add_argument(<span class="hljs-string">&quot;-s&quot;</span>, <span class="hljs-string">&quot;--scene&quot;</span>, <span class="hljs-built_in">type</span>=<span class="hljs-built_in">int</span>, default=<span class="hljs-number">20220621</span>, <span class="hljs-built_in">help</span>=<span class="hljs-string">&quot;想定编号&quot;</span>)<br>    parser.add_argument(<span class="hljs-string">&quot;-dp&quot;</span>, <span class="hljs-string">&quot;--data_path&quot;</span>, <span class="hljs-built_in">type</span>=<span class="hljs-built_in">str</span>, default=<span class="hljs-string">&quot;./logs/data/&quot;</span>, <span class="hljs-built_in">help</span>=<span class="hljs-string">&quot;解析数据路径&quot;</span>)<br>    parser.add_argument(<span class="hljs-string">&quot;-sc&quot;</span>, <span class="hljs-string">&quot;--scope_on&quot;</span>, action=<span class="hljs-string">&quot;store_true&quot;</span>, default=<span class="hljs-literal">False</span>, <span class="hljs-built_in">help</span>=<span class="hljs-string">&quot;是否解析视野&quot;</span>)<br>  <br>    parser.print_help()<br>    <span class="hljs-keyword">return</span> parser.parse_args()<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    args = parse_args()<br></code></pre></div></td></tr></table></figure><p>先给出一个例子。具体的流程是：</p><ul><li><p>先实例化一个 <code>ArgumentParser</code>可以添加描述。</p><ul><li>官方文档中还有其余的属性<br><img src="https://by3302files.storage.live.com/y4mJNjqUbkRtw0yibJEHVpamztvolm22ce2nFuZtxVZ1VgibrF8mFt7uTu8S6X0bUwu4MLGj3rt8bi2poj-A9BdaCKfHXgxhelLV3cagIaCpB8xdqqysD-zGisjV2LvIlWMmRYJtE9MM9EezEcqe7wOk5HP9UGGuh-GqBYm6Tv2uxBrieCXs9v3tuQEyo7aaU-J?width=817&height=524&cropmode=none" alt="ArgumentParser" title="ArgumentParser属性"></li></ul></li><li><p>然后调用 <code>add_argument</code>方法添加命令行选项<br><img src="https://by3302files.storage.live.com/y4maWV3d07DQSL5IGeVCVf7D4vdZuNyY-C-vBuLRdFcLDnlqzGs-ZJOWvZn1knE5MzNXk4jqMItmQncI6fsGnNycdxUQ-oeUzaTMmCe6xgn7rorPiraIFop-iOfNICje333kKrZR4TTAAhYr6sdoHoNQs0kR6kAAb95R4RddtSjjkbY5als1fbhwmMCQFEo6VH2?width=802&height=491&cropmode=none" alt="add_argument" title="add_argument方法 "></p><ul><li><p>name or flags用于识别参数选项，其中有-或者–前缀的是可选命令，如果不加前缀则是位置参数（positional argument) 如运行需要的文件名。</p><figure class="highlight python-repl"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python-repl"><span class="hljs-meta">&gt;&gt;&gt;</span> <span class="python">parser = argparse.ArgumentParser(prog=<span class="hljs-string">&#x27;PROG&#x27;</span>)</span><br><span class="hljs-meta">&gt;&gt;&gt;</span> <span class="python">parser.add_argument(<span class="hljs-string">&#x27;-f&#x27;</span>, <span class="hljs-string">&#x27;--foo&#x27;</span>)</span><br><span class="hljs-meta">&gt;&gt;&gt;</span> <span class="python">parser.add_argument(<span class="hljs-string">&#x27;bar&#x27;</span>)</span><br><span class="hljs-meta">&gt;&gt;&gt;</span> <span class="python">parser.parse_args([<span class="hljs-string">&#x27;BAR&#x27;</span>])</span><br>Namespace(bar=&#x27;BAR&#x27;, foo=None)<br><span class="hljs-meta">&gt;&gt;&gt;</span> <span class="python">parser.parse_args([<span class="hljs-string">&#x27;BAR&#x27;</span>, <span class="hljs-string">&#x27;--foo&#x27;</span>, <span class="hljs-string">&#x27;FOO&#x27;</span>])</span><br>Namespace(bar=&#x27;BAR&#x27;, foo=&#x27;FOO&#x27;)<br><span class="hljs-meta">&gt;&gt;&gt;</span> <span class="python">parser.parse_args([<span class="hljs-string">&#x27;--foo&#x27;</span>, <span class="hljs-string">&#x27;FOO&#x27;</span>])</span><br>usage: PROG [-h] [-f FOO] bar<br>PROG: error: the following arguments are required: bar<br></code></pre></div></td></tr></table></figure></li><li><p>action是指接受参数之后要执行的动作，通常是 <code>store_false</code>，<code>store_true</code>或者 <code>store_const</code>，不需要接受其余参数，直接将对应的选项变量保存为特定的值。这是使用得比较多的选项。<code>append</code>是一个特殊的action，它会将参数追加到列表中。<code>count</code>是一个特殊的action，它会将参数计数，并将计数值保存到变量中。</p></li><li><p>其他还有一些方法这里就不再赘述了，具体使用的时候可以参考官方文档。</p></li></ul></li><li><p>最后调用 <code>parse_args</code>方法解析命令行参数，返回一个 <code>Namespace</code>对象，其中包含了所有的参数。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>教程</category>
      
      <category>python使用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>argparse</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker build中的常见错误及常用命令(未完)</title>
    <link href="/2022/06/24/Docker%E5%AE%89%E8%A3%85%E4%B8%8E%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E6%93%8D%E4%BD%9C%E4%B8%8E%E9%97%AE%E9%A2%98/"/>
    <url>/2022/06/24/Docker%E5%AE%89%E8%A3%85%E4%B8%8E%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E6%93%8D%E4%BD%9C%E4%B8%8E%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>Docker安装和从docker file build网上应该有教程，这里记录一下我自己在安装pymarl所遇到的一些问题及一些常用命令。目前只写了一点点，后续会继续在这篇博文之中添加。</p><h3 id="一-常用命令"><a href="#一-常用命令" class="headerlink" title="一. 常用命令"></a>一. 常用命令</h3><p>   docker删除镜像：</p><ol><li><p>删除容器</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">docker ps <span class="hljs-comment">#查看正在运行的容器</span><br><br>docker ps -a <span class="hljs-comment">#查看所有容器</span><br><br>docker rm container_id <span class="hljs-comment">#删除容器</span><br></code></pre></div></td></tr></table></figure></li><li><p>删除镜像</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">docker images //查看镜像<br><br>docker rmi image_id<br><span class="hljs-comment"># 删除 null image</span><br><br>sudo docker rmi $(docker images -f <span class="hljs-string">&quot;dangling=true&quot;</span> -q) <span class="hljs-comment">#删除所有镜像</span><br><br><span class="hljs-comment"># 删掉容器</span><br>docker stop $(docker ps -qa)<br>docker rm $(docker ps -qa)<br><br><span class="hljs-comment"># 删除镜像</span><br>docker rmi --force $(docker images -q)<br><br><span class="hljs-comment"># 删除名称中包含某个字符串的镜像</span><br><span class="hljs-comment"># 例如删除包含“some”的镜像</span><br>docker rmi --force $(docker images | grep some | awk <span class="hljs-string">&#x27;&#123;print $3&#125;&#x27;</span>)<br></code></pre></div></td></tr></table></figure><h3 id="二-常见错误"><a href="#二-常见错误" class="headerlink" title="二. 常见错误"></a>二. 常见错误</h3></li><li><p>debconf: delaying package configuration, since apt-utils is not installed是说<code>apt-utils</code> 没有安装，对结果并没有什么危害，只是影响交互式安装。这个<code>apt-utils</code> 可以实现在安装过程中交互式配置文件，可以通过：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">RUN apt-get install --assume-yes apt-utils<br></code></pre></div></td></tr></table></figure><p>忽略掉这个警告信息。</p></li><li><p>InRelease:InRelease: The following signatures couldn’t be verified because the public key is not available</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys　425956BB3E31DF51<br>sudo apt update<br></code></pre></div></td></tr></table></figure><p>如果不行的话可以尝试在docker file中添加，<code>RUN rm/etc/apt/sources.list.d/cuda.list</code></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>教程</category>
      
      <category>Docker使用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PSRO笔记</title>
    <link href="/2022/06/20/PSRO%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/06/20/PSRO%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p><a href="https://arxiv.org/pdf/1711.00832.pdf">PSRO</a>这篇文章看了很久还是看不懂，慢慢做点笔记。</p><p>最简单最传统的多智能体即为InRL，即为每个智能体分别独立训练，但是会遇到不稳定（non-stationary）及非马尔科夫（non-Markovian)。非马尔科夫性我的理解即为，上一轮训练收敛的策略与下一轮训练没有确定的相关性，这一点也跟不稳定相对应。在这种情况下，训练只会得到相互过拟合的智能体，没有办法获得泛化的能力。</p><p>本文提出了一种独立学习产生的策略之间相关性的度量方式，并且证明了过拟合问题的严重性。给出的算法应该是从一系列的策略分布中选出得出一个混合策略。</p><blockquote><p>中心化训练分布式执行：</p><ul><li>Fully Decentralized: 去中心化，每个agent是独立的个体，彼此之间不交流</li><li>Fully Centralized: 完全中心化，所有agent都把信息传递给中央控制器central controller，中央控制器指导所有agents的动作、状态以及奖励。agent自己没有策略网络（不做决策），决策都由中央控制器来做。</li><li>Centralized training and decentralized execution：agents各自有各自的策略网络，训练的时候有一个中央控制器，它会收集所有agents的动作、状态以及奖励。中央控制器帮助agents训练策略网络，训练结束之后就不再用中央控制器了。每个agents根据自己的策略网络做决策。</li></ul><p>作者：凌晨一點钟的猫<br>链接：<a href="https://zhuanlan.zhihu.com/p/331722990">https://zhuanlan.zhihu.com/p/331722990</a></p></blockquote><blockquote><p>正则形式的博弈(Normal-form game):</p><p>正则形式是博弈论中描述博弈的一种方式。与扩展形式的博弈（extensive form game）不同，正则形式不用图形来描述博弈，而是用矩阵来陈述博弈。与延展形式的表述方式相比，这种方式在识别出严格优势策略和纳什均衡上更有用，但会丢失某些信息。博弈的正则形式的表达中包括每个参与者所有显然的和可能的策略，以及和与其相对应的收益。</p><p>在完全信息的静态博弈（static games of complete，perfect information）中，正则形式的表达形式是参与者的策略空间（strategy space）和收益函数（payoff function）。策略空间是某个参与者的所有可能策略的集合而策略是参与者在博弈的每个阶段——不管在博弈中这个阶段实际上是否会出现——将要采取的行动的完整计划。每个参与者的收益函数，是从参与者策略空间的向量积到该参与者收益集合（一般是实数集，数字表示基数效用或序数效用——在正则形式的表述方式中常常是基数效用）的映射。也就是说，参与者的收益函数把策略组合（所有参与者策略的清单）作为它的输入量，然后输出参与者的收益。</p></blockquote><blockquote><p>博弈论中，与正则形式相对应，扩展形式是一种通过树来描述博弈的表达方式。每个节点（称作决策节点）表示博弈进行中的每一个可能的状态。博弈从唯一一个初始节点开始，通过由参与者决定的路径到达终端节点，此时博弈结束，参与者得到相应的收益。每个非终端节点只属于一个参与者；参与者在该节点选择其可能的行动，每个可能的行动通过边从该节点到达另一个节点。和正则形式不同，扩展形式允许互动的显式模型（explicit modeling of interactions），互动中，一个参与者可以在博弈中多次行动，并且在不同的状态中可以做出不同的行为。</p></blockquote><p>正则形式的博弈可以看作，所有参与者的行动是同时作用在系统上的，所以可以建立收益矩阵，而扩展形式的博弈则参与者是交替参与（动态博弈）。关于子博弈的理解：<a href="https://www.zhihu.com/question/27102628/answer/35440374">如何从博弈树中划分出各个子博弈？贝叶斯法则如何使用？</a></p><p>PSRO的思想为，对于正则形式的博弈，采用其他智能体的元策略来训练本智能体的近似最佳反应，也即固定其余智能体的现有策略（未必是一个）来训练本智能体。因为不是共同进化，所以才叫做近似最佳反应（approximate best response)。得出的本智能体的策略再加入策略集合去训练其余智能体。DCH则更进一步，将智能体划分为k个阶段并行训练。，最终得到满足纳什均衡的各方策略。作者使用了PRD（projected replicator dynamics），给定一个智能体策略池中选取某策略的最低概率，从而强化探索。</p><p>本文与我想做的多智能体RTS想去甚远，但是对于对抗游戏而言，可以借鉴本文的训练方式，思考如何在扩展形式的博弈中求得纳什均衡。</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>强化学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RL</tag>
      
      <tag>ML</tag>
      
      <tag>MARL</tag>
      
      <tag>PSRO</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>劳动节随笔二零二二</title>
    <link href="/2022/04/22/%E5%8A%B3%E5%8A%A8%E8%8A%82%E9%9A%8F%E7%AC%94%E4%BA%8C%E9%9B%B6%E4%BA%8C%E4%BA%8C/"/>
    <url>/2022/04/22/%E5%8A%B3%E5%8A%A8%E8%8A%82%E9%9A%8F%E7%AC%94%E4%BA%8C%E9%9B%B6%E4%BA%8C%E4%BA%8C/</url>
    
    <content type="html"><![CDATA[<p>一</p><p>I’ve long been trapped in a circle of fighting against myself. Up till now, still I have no idea why things falled in such a rush. With no bravery to expose the trouble of myself, I swallowed the pill of escapism and maybe some cynicism as a transitory and illusory relief. In a way, it is equivalent to the confession of personal failure. Or even worse, it’s distorted by this gloomy era where people with no faith couldn’t breathe. It’s intensified from a perspective of some random or once hard-working small-town guy gradually get a glance of the ruthless operation mechansim of Chinese society. It’s disturbed by the huge obstacles standing in between traditional parenting full of emotional abuse, high requirements and nearly no postive response and modern education. The first one pictures a gray future for everyone. The second one only tells a more hopeless story about alienation of human-beings by so-called capitalism or other cults. If the age of 21 century devours future, the last one is about the past with extra meaningless tolerance towards poverty or feelings about unsafety or conflicts within traditional Chinese families. Here, I am not to say, it is all because of such a miserable objective outside world so that I couldn’t stand anymore. No, things are not working like that. I know many etraordinary people who dare to overcome all kinds of sufferings. More or less, there may be a generation of the species who resist and win. They set a perfect example for me as well. However, the key-point is, such negative environment changes my mind eternally.</p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>劳动节</tag>
      
      <tag>2022</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于2021的一点想法</title>
    <link href="/2021/03/01/%E5%85%B3%E4%BA%8E2021%E7%9A%84%E4%B8%80%E7%82%B9%E6%83%B3%E6%B3%95/"/>
    <url>/2021/03/01/%E5%85%B3%E4%BA%8E2021%E7%9A%84%E4%B8%80%E7%82%B9%E6%83%B3%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>也算是已经工作了近五个月，现在来谈一谈自己的感想。实际上我对于这份工作还是感激的成分比较多，因为彼时的我仍然处于抑郁的状态，行动力极其有限。有这么一个机会能够脱离家庭环境进入社会环境，对我来说算是一个小小的转折 。不过显然，如果当初去了体制内，或许结果会更加的不同。总而言之，在这短短的5个月里，似乎是看西洋景一般，体验到了很多新奇的经历，证明了自己总算是还没有退化，可以承担一些任务。</p><a id="more"></a><p>但是同时也感受到自身明显的缺陷——这不奇怪，毕竟我本来就是什么也不会。在工作中。</p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>新年</tag>
      
      <tag>蒲草集</tag>
      
      <tag>计划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>回乡偶记</title>
    <link href="/2021/02/19/%E5%9B%9E%E4%B9%A1%E5%81%B6%E8%AE%B0/"/>
    <url>/2021/02/19/%E5%9B%9E%E4%B9%A1%E5%81%B6%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="（一）"><a href="#（一）" class="headerlink" title="（一）"></a>（一）</h3><p>故乡也无非是这样。几般琐事，各自凉薄。独自在街道上夜游了很久，过公园大门而折返，又去看郎川。新年里灯光晦暗，流水汩汩。这里从前定有夜渔的人。我甚至能够想象，旧年的正月，人们正是在此游船互访，星月点点，这河运码头连着老街，送往迎来，喧嚣异常。</p><p>有一段时间想去翻建平史料，也在油管看到日本兵进城的段落。山川风物，历史典故，相较桑梓，我所知也绝不为少。然而说不清楚，道不分明。我并不知悉这里的十万家灯火，其与我也永远不会生出任何干系。以某种怀疑论的姿态来看，我之所爱，也无非是某种习惯，某些记忆。又或者仅仅是对北京的不爱罢了。</p><p>在街头徘徊而无所适从，也会觉得，乡土中国自有其魅力，传统形成了强而有力的势场，塑造着人们的一举一动，也由此形成极其复杂而稳健的社会动力学系统。其精巧，其严密，的确每每在某一时刻令人安心。</p><p>不过这显然也是极大的耗费。我从来不啻于谈及人类的粗鄙与卑劣，不吝于表达对人类社会的失望与嘲讽。这系统能够给人带来幸福，当然也就带来痛苦。烦难之处在于，这既是一种社会意识，也是一种社会无意识。仅仅通过各种不幸，我们能够勾勒出其边界，将其作为某种更为普遍的结构。然后将这种种，淹没在经文与诗颂当中。</p><p>我本人自是离经叛道的人，一面觉得可笑，另一面也因此孤僻起来。随意地发些感慨，一切皆为法，如梦幻泡影。 如露亦如电，应作如是观。</p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>新年</tag>
      
      <tag>蒲草集</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>WSL安装及用miniconda创建python3.7环境</title>
    <link href="/2021/02/07/WSL%E5%AE%89%E8%A3%85%E5%8F%8A%E7%94%A8miniconda%E5%88%9B%E5%BB%BApython3-7%E7%8E%AF%E5%A2%83/"/>
    <url>/2021/02/07/WSL%E5%AE%89%E8%A3%85%E5%8F%8A%E7%94%A8miniconda%E5%88%9B%E5%BB%BApython3-7%E7%8E%AF%E5%A2%83/</url>
    
    <content type="html"><![CDATA[<p>WSL在windows上的确相当的鸡肋，但是假若没有配置服务器，WSL配合VSCode，也可以充当生产力工具。比较大的bug是，WSL的文件与NTFS的文件系统并不同步，可能是创建了多个缓存，因此需要不断地Reload来更新。如果有服务器资源或者Linux桌面版，那么配合VSCode远程开发工具就已经很香了。以下是WSL的安装教程。</p><a id="more"></a><h3 id="1-WSL准备"><a href="#1-WSL准备" class="headerlink" title="1. WSL准备"></a>1. WSL准备</h3><p>参考文章：<a href="https://zhuanlan.zhihu.com/p/104060131">vscode wsl入门 - tnnmigga的文章 - 知乎</a></p><ul><li><p>首先要在windows打开linux子系统功能<br>控制面板——程序——启用或关闭windows功能——适用于linux的windows子系统</p></li><li><p>然后重启电脑</p></li><li><p>打开win10应用商店，搜索Ubuntu</p></li><li><p>下载安装好后启动，可以看到Ubuntu bash， 几分钟后初始化完成（这里没有提示，几分钟后按Enter键）即可。输入用户名: dison （不能有大写字母，这里dison用于用户指代，可以输自己的名字）及密码。</p></li><li><p><code>&lt;u&gt;</code>如果不喜欢用Ubuntu自带的bash的话可以使用Pycharm或者vscode的terminal，方便代码的复制粘贴。直接在terminal中输入wsl或者Ubuntu就可以打开Ubuntu子系统 <code>&lt;/u&gt;</code></p></li><li><p>换源</p><ul><li><p>获取权限</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">sudo chown -R dison /etc/apt/sources.list<br></code></pre></div></td></tr></table></figure></li><li><p>备份原文件</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">sudo cp /etc/apt/sources.list /etc/apt/sources.list.bak<br></code></pre></div></td></tr></table></figure></li><li><p>编辑源</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">sudo vim /etc/apt/sources.list<br></code></pre></div></td></tr></table></figure><p>打开sources.list后按i键进入insert模式，将原来的源都用#注释掉。（如果会使用vim编辑器可以使用其他的快捷键）</p><p>复制下面的源：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释</span><br>deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal main restricted universe multiverse<br><span class="hljs-comment"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal main restricted universe multiverse</span><br>deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-updates main restricted universe multiverse<br><span class="hljs-comment"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-updates main restricted universe multiverse</span><br>deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-backports main restricted universe multiverse<br><span class="hljs-comment"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-backports main restricted universe multiverse</span><br>deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-security main restricted universe multiverse<br><span class="hljs-comment"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-security main restricted universe multiverse</span><br><br><span class="hljs-comment"># 预发布软件源，不建议启用</span><br><span class="hljs-comment"># deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-proposed main restricted universe multiverse</span><br><br><span class="hljs-comment"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-proposed main restricted universe multiverse</span><br></code></pre></div></td></tr></table></figure><p>光标移到最下方右键单击粘贴源。</p></li></ul><p>按Esc键退出编辑模式，依次输入 :wq保存更改。</p><ul><li>更新源文件</li></ul><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">sudo apt update<br></code></pre></div></td></tr></table></figure><h3 id="2-安装miniconda"><a href="#2-安装miniconda" class="headerlink" title="2. 安装miniconda"></a>2. 安装miniconda</h3></li></ul><p>参考文章：<a href="https://blog.csdn.net/weixin_30486037/article/details/97982277">在Ubuntu上安装Miniconda</a></p><ul><li><p>下载并安装</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">sudo apt-get install wget<br>wget https://repo.anaconda.com/miniconda/Miniconda3-latest-Linux-x86_64.sh<br>bash Miniconda3-latest-Linux-x86_64.sh<br></code></pre></div></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 一直按回车然后输入yes</span><br>please answer <span class="hljs-string">&#x27;yes&#x27;</span> or <span class="hljs-string">&#x27;no&#x27;</span>:<br>&gt;&gt;&gt; yes<br><br><span class="hljs-comment"># 选择安装路径, 文件名前加点号表示隐藏文件</span><br>Miniconda3 will now be installed into this location:<br>&gt;&gt;&gt; ~/.miniconda3<br><br><span class="hljs-comment"># 添加配置信息到 ~/.bashrc文件</span><br>Do you wish the installer to initialize Miniconda3 by running conda init? [yes|no]<br>[no] &gt;&gt;&gt; yes<br></code></pre></div></td></tr></table></figure></li><li><p>运行配置信息文件</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">source</span> ~/.bashrc<br></code></pre></div></td></tr></table></figure></li><li><p>测试是否安装成功</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">conda --version<br></code></pre></div></td></tr></table></figure></li><li><p>如果是服务器用户，可以在Miniconda文件夹同目录下创建.condarc文件增加如下channel：</p><figure class="highlight json"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs json">channels:<br>  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/pytorch/<br>  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/<br>  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/<br>  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge/<br>ssl_verify: true<br><br></code></pre></div></td></tr></table></figure><p>也可以用如下命令添加源。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/pytorch/<br></code></pre></div></td></tr></table></figure><h3 id="3-python3-7及相关包安装"><a href="#3-python3-7及相关包安装" class="headerlink" title="3. python3.7及相关包安装"></a>3. python3.7及相关包安装</h3></li><li><p>如果已经进入了base环境可以用如下命令退出环境</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">conda deactivate<br></code></pre></div></td></tr></table></figure></li><li><p>创建python3.7环境</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">conda create -n venv python=3.7<br></code></pre></div></td></tr></table></figure></li><li><p>激活虚拟环境</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">conda activate venv<br></code></pre></div></td></tr></table></figure></li><li><p>安装相关包</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">conda install pandas<br>conda install pika<br>conda install pymysql<br>conda install xlrd=1.2.0<br>conda install matplotlib<br>conda install openpyxl<br>conda install pytorch torchvision torchaudio cudatoolkit=10.2 -c pytorch<br></code></pre></div></td></tr></table></figure><h3 id="4-运行说明"><a href="#4-运行说明" class="headerlink" title="4.运行说明"></a>4.运行说明</h3></li><li><p>路径说明</p><p>WSL能够运行Windows系统中的文件，需要在路径前加上/mnt，比如切换到D盘即为</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /mnt/d<br></code></pre></div></td></tr></table></figure></li><li><p>由于.so文件使用了python3.7编译，因此在运行程序前先激活python3.7环境，然后再运行相关脚本</p><figure class="highlight applescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs applescript">conda <span class="hljs-built_in">activate</span> venv<br></code></pre></div></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>教程</category>
      
      <category>Linux使用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>WSL</tag>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>勃学：成功人士的最后一次失败</title>
    <link href="/2021/02/07/%E5%8B%83%E5%AD%A6%EF%BC%9A%E6%88%90%E5%8A%9F%E4%BA%BA%E5%A3%AB%E7%9A%84%E6%9C%80%E5%90%8E%E4%B8%80%E6%AC%A1%E5%A4%B1%E8%B4%A5/"/>
    <url>/2021/02/07/%E5%8B%83%E5%AD%A6%EF%BC%9A%E6%88%90%E5%8A%9F%E4%BA%BA%E5%A3%AB%E7%9A%84%E6%9C%80%E5%90%8E%E4%B8%80%E6%AC%A1%E5%A4%B1%E8%B4%A5/</url>
    
    <content type="html"><![CDATA[<p>在去年三月我曾经对勃学发表了一番小小的意见，虽然无甚价值，但是修复了博客，重新上传一下：</p><a id="more"></a><blockquote><p>尽管勃学在知乎已经消退很久了，但是一直关注着这个小小的亚文化。在批判前首先要说明的是，作为一种亚文化，勃学的什么吸引着我们？毫无疑问，失败是勃学的核心。浅色床单，浙江大学，或者没有去牛组，或者最后做CS，在勃学语境中，被赋予失败的涵义。与之相对，去清北，去北美top10，去牛组，去大公司，做出fancy的成果，拿到相应的回报，便是勃学语境下的成功。他们本以为是唾手可得的，早就设想好的，却在咫尺之间分道扬镳，因为某一个选择，因为现实条件，客观因素，人生进入了“失败组”，并且就此断定，失败是永恒的，成功不过是那些有着更好家世背景，social network，或者八面玲珑，收割韭菜的产物。</p><p>不论如何定义成功和失败，失败是永恒的这个论断，首先是残酷现实的。正因为如此，当年轻人遭遇到了第一次失败的时候，会欣然投入勃学的怀抱——我也有错，但是世界当然也有错。承认并且拥抱失败，这是勃学给我们的积极暗示，是勃学的元命题。这个结论，堪比加缪的荒谬哲学。就像荒谬哲学只能进入意识到世界荒谬本质的人的脑海中一样，勃学对于失败者的迎合，是这个亚文化得以不断生长的原动力。</p><p>但是仅此而已，或许是缺乏社交媒体的传播，使得勃学在本质上变成了某种私密的价值观。除了失败是永恒的这一论断以外，勃学的其他阐述都仅仅依赖于勃学家们个人的生命体验。比如，在湾区当码农，年入百万，对勃学家们是失败，但是对绝大多数人来说当然是成功了。而在勃学家们的言谈举止中他们其实也不讳言这一点，他们已经得到了世俗意义的成功。比如立党会去假扮美国底层，但是他也会神气十足地说他在休斯敦最好的区。“我得到了很多，但是我失去的更多。”这大概是他们的失败逻辑。诡辩当然是可以的，毕竟这是他们真实的经历，他们的朋友同事同学都成功了，而他们则失败了。但是正因为这些经验本身，注定了勃学和勃学家们是缺乏关怀的。当曾勃自嘲三本的时候，绝对不会把三本放在眼里，同样，立党和美国底层也相去甚远。他们假扮着骑士，来揭穿欺骗韭菜的幌子，来传布勃学的真谛，但是这并不意味着他们关怀韭菜。梁山泊的好汉们要替天行道，但是杀起人来不也毫不手软嘛。缺乏关怀本身是勃学的致命弱点，这既是勃学无法被更多人接纳的原因，也是勃学家们自相矛盾的所在。明明为世界上最大的镰刀工厂服务，却鄙视起别的镰刀来。</p><p>勃学的第二个弱点在于解方，表面上勃学的终极结论是“自杀”，但是实际上勃学家个个都学着杨朱的法子，贵己重生。</p></blockquote><p>一年已经过去了，在这一年里很多都已经改变，包括勃学本身。事实上我也是最近才认识到，勃学早就已经死了，徐白左江，信徒不过是江湖故事，曾博也退化成互联网上的一只猫。我也不过在评论一堆废墟罢了。但是相比于一年以前，我已经不再讨厌他了。恰恰相反，我看到了一种坦诚。人不能欺骗别人，但首先不能欺骗自己。大众媒体侵蚀我们的生活，左右我们思想的时候，可能只有依靠这样的方法论，我们才能够真正接触到现实世界。浅色床单上的眼泪是真的，尽管也许故作姿态，但是我们也不能否认这一点。</p>]]></content>
    
    
    <categories>
      
      <category>评论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>勃学</tag>
      
      <tag>失败</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo的安装及使用</title>
    <link href="/2021/02/07/Hexo%E7%9A%84%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8/"/>
    <url>/2021/02/07/Hexo%E7%9A%84%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>本文主要介绍一下Hexo的安装与使用流程，以免自己忘记。</p><a id="more"></a><h3 id="一、Hexo的安装"><a href="#一、Hexo的安装" class="headerlink" title="一、Hexo的安装"></a>一、Hexo的安装</h3><h4 id="1-Hexo的安装"><a href="#1-Hexo的安装" class="headerlink" title="1. Hexo的安装"></a>1. Hexo的安装</h4><p>需要先安装nodejs以及git。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">npm install -g hexo-cli<br></code></pre></div></td></tr></table></figure><h4 id="2-Hexo的初始化"><a href="#2-Hexo的初始化" class="headerlink" title="2. Hexo的初始化"></a>2. Hexo的初始化</h4><p>Hexo安装完成后，在指定文件夹下初始化。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">hexo init &lt;folder&gt;<br><span class="hljs-built_in">cd</span> &lt;folder&gt;<br>npm install<br></code></pre></div></td></tr></table></figure><p>_config.yml下有网站的配置信息，可以在此配置大部分参数。具体配置及相关文档参见：<a href="https://hexo.io/zh-cn/docs/">Hexo文档</a></p><p>在github上创建名为<code>username.github.io</code>的仓库，在_config.yml文件的deploy部分配置自己的git仓库地址，将分支改为master。</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">deploy:</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">git</span><br>  <span class="hljs-attr">repo:</span> <span class="hljs-string">https://github.com/Coldison/coldison.github.io.git</span><br>  <span class="hljs-attr">branch:</span> <span class="hljs-string">master</span><br></code></pre></div></td></tr></table></figure><h3 id="二、Fluid主题配置"><a href="#二、Fluid主题配置" class="headerlink" title="二、Fluid主题配置"></a>二、Fluid主题配置</h3><p>我选择的是fluid主题，参见<a href="https://hexo.fluid-dev.com/docs/start/#%E4%B8%BB%E9%A2%98%E7%AE%80%E4%BB%8B">Fluid 主题文档</a>。</p><p>将Fluid主题文件解压，放到themes目录下并且改名fluid。在<code>_config.yml</code>中将theme改为fluid。然后将fluid文件夹下的 <code>_config.yml</code>改名为<code>_config.fluid.yml</code>，复制到<code>_config.yml</code>同级文件夹。然后就可以在<code>_config.fluid.yml</code>修改相应的style了。</p><p>主要是修改配色，链接以及文本。我选择了偏灰的颜色，超链接是紫色系，具体可以自己修改。</p><h3 id="三、Hexo命令"><a href="#三、Hexo命令" class="headerlink" title="三、Hexo命令"></a>三、Hexo命令</h3><p>写作：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">hexo new [layout] &lt;title&gt;<br></code></pre></div></td></tr></table></figure><p>主要有post，page，draft三种，路径都是source。</p><p>也可以自己创建模板。</p><p>常用命令：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">hexo g <span class="hljs-comment">#完整命令为hexo generate,用于生成静态文件</span><br>hexo s <span class="hljs-comment">#完整命令为hexo server,用于启动服务器，主要用来本地预览</span><br>hexo d <span class="hljs-comment">#完整命令为hexo deploy,用于将本地文件发布到github上</span><br>hexo n <span class="hljs-comment">#完整命令为hexo new,用于新建一篇文章</span><br>hexo g -d <span class="hljs-comment">#两个命令的合成，一般在修改或者添加博文后直接使用这个命令</span><br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>教程</category>
      
      <category>博客设置</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>fluid</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>在人间</title>
    <link href="/2020/05/16/%E5%9C%A8%E4%BA%BA%E9%97%B4/"/>
    <url>/2020/05/16/%E5%9C%A8%E4%BA%BA%E9%97%B4/</url>
    
    <content type="html"><![CDATA[<p>离群索居久了，似乎连话也不会说，文章也很少写了。大概有某种投降的意思，放弃了思考和改变，因此也没有什么可以写的内容，甚至连机能也退化了。</p><a id="more"></a><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=1341066656&auto=1&height=66"></iframe><p>对于某些人来说，这当然也不是坏事。所谓人类一思考，上帝就发笑。鼓起勇气去了同学之间的小聚，Z就很看得开，什么波澜壮阔，按部就班一点一点来，于时代来说表现得是一个正常人，也绝无可笑之处。大概大多数人也是如此，像是攀缘的爬山虎，一分一毫，最后总得要到高处去。又或者是北来的归燕，早已在廊檐下凭借着自己，筑了精致的巢穴，也无风雨也无晴。日常呼朋引伴，胡吃海塞，天南地北流窜，谓之情谊。所纠结所烦难，无非是目力所及，心之所向。今日事不能毕，昨日情难以了。这些人，于家于国，都算是中流砥柱，并不会自怨自艾，不会说什么，现实的引力太沉重了这样的屁话，也无甚必要。对我来说，算是某种参照系。</p><p>我读初中的时候，很喜欢看高尔基的三部曲。第一二部讲少年的故事，我的少年生活倒不算如意，所以时时感触，特别觉得书里面的外祖父像极了我的爷爷。等我脱离了这层桎梏，便开始羡慕起青年高尔基来。所有完整的情节现在是记不清了，只记得他最开始去给画圣像的当学徒，和作坊的许多工友混在一起，认识了很多粗鲁且善良的劳动人民，后来又去船上，周游到了里海去。那时我就想，我也想去认识这许多人，去这许多地方。高中的时候翻看《从文自传》，沈从文当着兵，在军队里面流转，并不像在学校里面的孩子们，早早就见识了冷酷仙境，美艳的老板娘，土匪的爱情故事，下到兵痞，上到将军。固然是沈从文诗化了湘西，但是这并不妨碍我的向往。</p><p>这里关乎一个很要紧的问题，什么是人间。人的认知空间到底还是狭小。日常的生活经验，并不足以使我们认识到，人间到底是什么样子。看关口知宏的《中国铁道大纪行》，发现零几年的铁路上，人们像动物一样，早早就开始了季节性的长途奔徙。做着各种各样的生计，并不因此沮丧，对待日本来的客人，也一样真诚善良。这些我都无知无识。北京南站，每一天都会涌来和散去很多的人们，我有心观察过，拎着蛇皮袋的，拖家带口的，大腹便便穿polo衫拎公文包的，衣冠楚楚胸前也挂吊牌的。火车上，听见过有去北京探亲的，看过有两个秃头大爷在火车上喝白酒，还有在连接处不停电话谈业务的。这些人，我绝不知道他们的故事。恍恍惚惚闲云逸鹤，人间红尘过。</p><p>以上大概是某种朴素的价值判断和审美倾向，是我对于现实的某种把握。但是，请不要误会，也许我很久以前想过，但是现在我绝不想做一个吟游诗人。四处游历，和人交谈，固然美妙，如果能以此为生，那便是很多人梦寐以求的了。然而浮于表面的始终浮于表面，这是我个人有所改观的地方。从前的我会觉得，认知的广度和深度足够用来处理现实的问题，现在我大概能够明白，现实生活的经验仍旧是第一位的。物理上对于真理的探查，实际上是用干涉的手段完成的。纯粹的观察者，仅仅意味着，观察的对象于自身无关紧要罢了。这也是我依旧喜欢高尔基和沈从文的原因——他们本人和所看见的人间，是相互塑造的。于是，这些也改变了他们的命运，前者没有在圣像作坊里埋头到老，后者也没有成一个老兵油子在战场上送命，这才使得我们能够窥见他们青年世界的一瞥。</p><p>是在人间，而不是人间。</p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>蒲草集</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>新年随笔二零一九</title>
    <link href="/2019/01/10/%E6%96%B0%E5%B9%B4%E9%9A%8F%E7%AC%94%E4%BA%8C%E9%9B%B6%E4%B8%80%E4%B9%9D/"/>
    <url>/2019/01/10/%E6%96%B0%E5%B9%B4%E9%9A%8F%E7%AC%94%E4%BA%8C%E9%9B%B6%E4%B8%80%E4%B9%9D/</url>
    
    <content type="html"><![CDATA[<p>往往有一种错觉，旧历年还没有过去，新历年已经来临的这段日子，仿佛每一天都是节日。好像是汽车的轮子也打着漂，即使是特别沉稳的人，也会在心里面默默盘算，要去哪里玩，什么样的衣服鞋子，什么样的大菜，乳猪哼哼唧唧趴在大圆桌子上，红透的大虾在盘子里面蹦哒。</p><a id="more"></a><p>倘若是旧时，我还在我们的村子占地为王的时候，我们一行人便会早早起床，趁着阳光没有那么强烈，小水库里面的冰还没有被朝阳触动的时候去砸冰。</p><p>早晨的空气冷冽，软湿的泥土结了冰，踩上去咔嚓咔嚓脆生生弄不脏鞋，路边的又灰又黄枯草也打了霜，白色的冰晶装饰着叶的边缘好像是愈发憔悴，好像是什么八大山人的怪石枯草。已经是冬月，已经是枯水期，黝黑的河床露出来，将水面分成一块一块，水面结的冰打着褶皱，在阳光下面闪闪发光。淤泥也仿佛硬气起来，我们蹑手蹑脚踩上去，挪到水边上，用红色的砂岩小石头去砸碎这面鱼虾的玻璃窗。透明的冰面被砸出洞来，被砸出裂缝，空气透进去，在冰下形成白色的气泡，叫人又有去砸碎的欲望。石子在冰面上滑行发出刺啦刺啦的啸声，我们比着谁的石头扔的远，河床上的石子瓦片扔完，就用碎冰。一厘米左右的冰片在冰面上喀拉碎成小块，每一片在又如水晶一般闪着光辉。喀拉喀拉喀拉，近处的冰也被我们扔完，冰面上一片狼藉，但是我们还不肯罢休。有带擦炮的，点燃一根，专门扔到冰窟窿里面去，等上三五秒，在水底闷地一声，乳白色的气泡冒上来，又被锁在冰面下，形成一个个奇形怪状的乳白色的空腔，久久也不能散去。</p><p>等到太阳又高一点，有妇人出来洗衣服，渔人穿上半身的塑胶衣服下水捞鱼，冰面被我们蹂躏得差不多，河床上的淤泥差不多也开始软趴趴的时候，我们便飞也似的逃窜，顺便捡上一两片蚌壳，等着明天再来这里逞威风……</p><p>这些差不多已经是十年前的光景，许多个日子团成一团，开始怀念的时候，也正如杜拉斯所说，记忆中只有广阔的场景，此处到彼处，光暗如何，冷暖几分，音容笑貌抽象成几个形容词，仿佛再也没有正眼瞧过他们的被冷风吹的红通通的脸，对话也都失去色彩。像是别处再起的楼阁，虚构出形制，草拟出蓝图，再把过去的自己安放其间。</p><p>沉湎于过去当然是极极愚蠢的行为，更何况这些旧人早已作鸟兽散，也听说过各种变故，有过得凄凄惨惨戚戚，有的业已成家，分道扬镳的时间比印象中的要早得多，结局当然也坏得多。之所以谈起这些，无非是时间的滤镜居然抹平了那些残破的记忆，在这流落的时候熠熠生辉起来。然后违心地去想，倘若再来一回，一定要记得所有人的样子，即刻就在心里编下这种种故事，记在日记里，省得这些事情萦绕起来，好像是某种温情，叫人失神。</p><p>辞旧迎新的时节，再谈这些总也不合时宜，总得也作些总结汇报，新年展望，把自己拾掇得像一个人，假模假样地胸前口袋夹着笔，拿着一张表，来来回回边踱步边打个分数。但也正因为难以下笔，所以才想到过去的平凡岁月，那些阳光灿烂的日子，何以逐渐模糊，被时间一一剪切归档，收藏在某个小小角落，然后又将这些素材拿出来，重新拼接剪辑，变成温情故事。然而往者终究不可谏，好像是我爱我家，梁左也已经去世了，京城中流传的早已经不是大院子弟的故事，甚至青春朋克都已经成为历史，命运的转轮不停地旋转，已经2019年了。</p><p>过去的一年，我撞过了每一堵我可能要撞的高墙，摔落了每一道我可能要落进的沟壑，口袋里的扑克牌一一散落，我的朋友在前面驻扎，而我也并不觉得风阻会减小一些。2019，无非也还是一日一日的日常，一日一日，我们假装严肃生活，只等时间裁剪片段，打磨上色，算是为未来保留温情。</p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>新年</tag>
      
      <tag>2019</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
